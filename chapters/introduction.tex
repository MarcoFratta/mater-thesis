%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

Simulating complex systems is a key part of modern research and engineering.
These systems are made up of many parts that interact with each other, creating behaviors that are hard to predict 
just by looking at the individual pieces.
To study things like how biological networks work or how a swarm of robots moves,
powerful simulation tools that can handle space, time, and randomness are required.

Alchemist is one such tool, designed to model these kinds of distributed systems.
But as simulations get more complicated, setting them up becomes a real challenge.
Right now, users have to write configuration files in YAML\footnote{\url{https://yaml.org/}}.
While YAML is easy to read in simple scenarios, it becomes hard to read and maintain in more complex scenarios. 
It also does not help to check if the configuration is actually correct 
until the simulation is executed.
This leads to frustration, errors, and wasted time.

This thesis proposes a better way to configure Alchemist simulations.
Rather than relying on static text files, a Kotlin-based Domain-Specific Language (DSL)~\cite{fowler2010domain} has been created. 
This enables users to author their configurations in a code-like manner, offering numerous advantages.
Checks are performed while typing, suggestions are provided by the Integrated Development Environment (IDE), 
and the chance of making mistakes is significantly reduced.
The goal is to make the process of setting up a simulation smoother and more reliable, enabling researchers to focus on their experiments 
rather than fighting with configuration files.

This thesis is organized as follows. 
\begin{itemize}

    \item Section~\ref{sec:context-motivation} details the context and motivation behind this project.
    \item Section~\ref{sec:background} provides background information about the Alchemist simulator and the 
    concept of Domain-Specific Languages.
    \item Chapter~\ref{chap:analysis} analyzes the requirements and constraints for developing the DSL,
    examining the limitations of the current YAML approach and establishing the domain model. 
    \item Chapter~\ref{chap:design} presents the design of the DSL, including its architecture and key design decisions. 
    \item Chapter~\ref{chap:implementation} describes the implementation details and challenges encountered during development. 
    \item Chapter~\ref{chap:evaluation} presents the evaluation of the DSL, detailing the methods and results of the assessments performed.
    \item Chapter~\ref{chap:conclusion} summarizes the contributions and discusses future work.
\end{itemize}

\newpage
\section{Context and Motivation}
\label{sec:context-motivation}
\subsection{Configuring Complex Systems}

Configuration constitutes a fundamental mechanism through
which users specify the structure, behavior, and parameters
of complex systems without modifying the underlying implementation. 
In the context of computational systems, configuration encompasses 
the specification of runtime characteristics, architectural topology,
behavioral policies, and experimental parameters that govern system
execution. Rather than encoding these aspects directly into program 
logic, configurations externalize them into separate artifacts that 
can be modified, versioned, and reused independently of the core 
codebase. This separation of concerns enables a single implementation 
to serve diverse use cases through different configurations.
To facilitate configuration authoring, many systems develop specialized 
Domain-Specific Languages (DSLs) tailored to their configuration needs. 
These DSLs provide syntax and abstractions that align with the domain concepts 
of the target system, making configurations more intuitive and less error-prone 
than generic data formats. Prominent examples include Docker's Dockerfile syntax\footnote{\url{https://docs.docker.com/reference/dockerfile/}}
for container image construction, Kubernetes manifests\footnote{\url{https://kubernetes.io/docs/concepts/workloads/controllers/deployment/}}
for orchestrating containerized 
applications, Spring Boot's\footnote{\url{https://docs.spring.io/spring-boot/index.html}} application properties and YAML configurations for 
dependency injection and application setup, Gradle's\footnote{\url{https://gradle.org/}} build configuration DSL 
for defining build scripts and dependencies. For example, in a simulation framework 
like Alchemist a simulation can be defined by creating a configuration 
file that specifies all the needed parameters such as the initial state and the 
behavior of its components. This configuration file can then be used to create a 
simulation instance that can be run.

    
\newpage
\subsubsection{Imperative and Declarative Configuration Paradigms}

Configuration management systems can be classified according to 
two distinct paradigms that fundamentally differ in their approach 
to system specification and manipulation: 
\begin{itemize}
    \item \textbf{Imperative paradigm}
    \item \textbf{Declarative paradigm}
\end{itemize}

This distinction, 
 rooted in the dichotomy between procedural and declarative 
 programming models, has profound implications for how 
 systems are configured, maintained, and reasoned about.

The \textit{imperative configuration} paradigm focuses on specifying \textbf{how} 
a system should reach its desired state through explicit sequences of 
commands and operations. An imperative configuration defines 
the procedural \textbf{steps} required to transform the system from its 
current state to the \textit{target state}. Each command represents an 
action that modifies system state, and the execution order is 
critical to achieve the intended outcome. Shell scripts and traditional system 
administration procedures exemplify this approach.
Another example of an imperative configuration is the \textit{Dockerfile} configuration file:
Docker is an open platform for developing, shipping, and running applications.
A \textit{Dockerfile} is the Docker's imperative configuration 
format for building container images. 
It is a text file containing instructions for building source code. 

\begin{minted}[fontsize=\footnotesize, linenos]{dockerfile}
FROM ubuntu:22.04
# install app dependencies
RUN apt-get update && apt-get install -y python3 python3-pip
RUN pip install flask==3.0.*
# install app
COPY hello.py /
# final configuration
ENV FLASK_APP=hello
EXPOSE 8000
CMD ["flask", "run", "--host", "0.0.0.0", "--port", "8000"]
\end{minted}
\captionof{lstlisting}
{Example of a Dockerfile configuration}

In this example, each \texttt{RUN}, \texttt{COPY}, and \texttt{CMD} instruction represents
 a step that modifies the container image state, 
 and the sequence must be carefully ordered 
 (e.g., installing packages before executing files that depend on them). 
 Docker then builds images by reading the instructions from a Dockerfile.

In contrast, the declarative configuration paradigm focuses 
on specifying \textbf{what} the desired system state should be,
abstracting away the procedural details of how that state is achieved. 
A declarative configuration describes the target state as a set
of constraints, properties, and resource specifications, 
delegating to the configuration management 
system the responsibility of determining and executing the
necessary operations to realize that state. 
The system automatically computes the necessary
set of changes required to achieve the desired state. 
Tools such as Docker Compose, Puppet\footnote{\url{https://help.puppet.com}}, 
Terraform\footnote{\url{https://developer.hashicorp.com/terraform/language}} and Kubernetes manifests 
exemplify this paradigm. 
Docker Compose, for example, allows developers to declare 
the desired state of multi-container applications using a YAML file:
\begin{minted}[fontsize=\footnotesize, linenos]{yaml}
services:
  web:
    build: .
    ports:
      - "8000:5000"
  redis:
    image: "redis:alpine"
\end{minted}
\captionof{lstlisting}
{Example of a Docker Compose configuration}

The declarative paradigm offers several advantages that have driven its
adoption across modern infrastructure management. 
\begin{enumerate}
    \item Declarative configurations are
    inherently more readable and maintainable, as they document the intended system state
    without obscuring it with implementation details.
    \item They are idempotent by design:
    applying the same configuration multiple times produces the same result, eliminating concerns
    about partial execution or repeated application.
    \item They facilitate reasoning about system properties through formal verification
     and constraint validation before deployment.
    \item They support more robust error handling, as the system
    can detect when the desired state cannot be achieved and report specific discrepancies.
\end{enumerate}

\subsubsection{Application Domains}

Declarative configuration systems have proliferated across diverse domains of software infrastructure, 
each addressing specific challenges. Understanding these application domains and their
 representative technologies provides 
context for the subsequent discussion of configuration challenges and the motivation
for type-safe configuration approaches proposed in this thesis.
Some application domains and representative systems are:
\begin{itemize}

\item \textbf{Infrastructure Configuration Management}:
Puppet pioneered the declarative configuration management paradigm for
physical and virtual server infrastructure.
Its resource abstraction model allows administrators to declare desired states for files,
packages, services, users, and other system entities.
Chef\footnote{\url{https://docs.chef.io/}} followed a similar philosophy while embedding configuration logic within a
Ruby domain-specific language, providing both declarative resource declarations and 
imperative programming constructs. 
These tools revolutionized system administration by replacing ad-hoc shell
scripts with version-controlled, testable configuration artifacts.

\item \textbf{Cloud Infrastructure Provisioning}:
Terraform extended declarative configuration to cloud resource provisioning, 
allowing operators to declare entire cloud environments, including compute instances, 
networks, load balancers, databases, and access policies, using a unified configuration language. 

\item \textbf{Container Orchestration}:
Kubernetes represents perhaps the purest expression of declarative configuration in modern infrastructure.
 The Kubernetes API defines a comprehensive schema of resource types such as 
 Pods, Services, Deployments, ConfigMaps, Secrets, and dozens of others,
 Users express desired states through YAML or JSON manifests, and Kubernetes controllers
  continuously reconcile actual cluster state with declared specifications.
\item \textbf{Build Automation}:
Build automation tools like Gradle provide hybrid models that combine
declarative DSLs with imperative logic when needed.

\item \textbf{Complex Systems Configuration}:
Scientific simulation frameworks like Alchemist employ 
declarative configuration files to specify complex experimental scenarios. 
Other simulation platforms, such as Eclipse MOSAIC\footnote{\url{https://eclipse.dev/mosaic/docs/}} for connected mobility simulations
and AWS SimSpace Weaver\footnote{\url{http://archive.today/BUt4k}} for large-scale spatial simulations, similarly utilize
declarative configuration files (JSON and YAML respectively) to define
simulation parameters and system structures. This approach enables researchers 
and developers to express sophisticated configurations 
without imperative programming, facilitating reproducibility 
and systematic parameter exploration.
\end{itemize}

These systems, while addressing distinct domains, share common architectural patterns:
\begin{itemize}
    \item{\textbf{Resource schema}}: defines the universe of entities that the configuration system can manage, 
    specifying the types of resources, their properties, validation rules, and semantic constraints. It 
    is the abstract model of the configuration system.
    \item{\textbf{Concrete syntax}}: provides a human-readable, version-controllable format for expressing configurations,
    supporting necessary abstraction, parameterization, and composition. Some systems, like Gradle and Terraform, 
    provide domain-specific languages with built-in
    abstraction primitives such as modules, variables, and iteration constructs. Others, like Kubernetes,
     define a pure data format (JSON/YAML). Different concrete syntaxes can target the same underlying resource schema.
    \item{\textbf{Configuration management engine}}: it is responsible for determining a valid sequence 
    of operations to achieve the desired state (respecting dependencies and constraints), 
    and execute those operations while handling errors and partial failures. 
\end{itemize}


\subsection{Challenges and Limitations}

Despite the architectural sophistication of declarative configuration systems,
 the concrete syntax layer has converged on a remarkably narrow set of data serialization formats. 
 XML (Extensible Markup Language), JSON (JavaScript Object Notation), 
 YAML (YAML Ain't Markup Language) have emerged as the most used data formats for expressing configuration artifacts 
 across different domains of modern software infrastructure. 
 This convergence reflects their perceived advantages: 
 human readability, widespread tool support, and interoperability with programming language data structures. 
 However, these formats have fundamental limitations that become increasingly problematic as configuration 
 complexity grows.

\subsubsection{Lack of Type Safety}

XML, JSON and YAML are fundamentally \textit{untyped} data formats. 
They represent data structures (objects, arrays, strings, numbers, booleans, and null values) without any 
mechanism for expressing type constraints, 
required fields, or value ranges. 
Type information exists only implicitly through runtime validation performed by the consuming application, 
which must parse the configuration and verify that values conform to expected types and constraints. 
This validation occurs entirely at runtime, meaning configuration errors surface only when the system attempts 
to load or execute the configuration,
 potentially after significant development effort has been invested.

Beyond the absence of type constraints, XML, JSON and YAML are fundamentally limited to primitive data
 types supported by 
the serialization format itself. 
These formats natively support only basic scalar types along with composite structures (objects and arrays) 
composed of these primitives.
This limitation becomes particularly problematic when configuration systems need to express domain-specific 
concepts that
 map to programming language classes, interfaces, or complex object types. 

Consider simulation frameworks like Alchemist, where configurations must specify classes that
 will be instantiated at runtime to
 represent domain entities. The YAML configuration expresses these class specifications as string literals:

\begin{minted}[fontsize=\footnotesize, linenos]{yaml}
incarnation: protelis
environment:
  type: Continuous2DEnvironment

network-model:
  type: ConnectWithinDistance
  parameters: [6]

deployments:
  type: Rectangle
  parameters: [1, 0, 0, 100, 100]
\end{minted}
\captionof{lstlisting}{Example of an Alchemist YAML configuration with class loading}

Here, class names such as \texttt{Continuous2DEnvironment}, 
\texttt{ConnectWithinDistance} and
\texttt{Rectangle} are specified as plain strings. 
The application must use reflection or factory patterns to resolve these string class 
names to actual Java or Kotlin classes at runtime, 
instantiate them with the provided parameters,
 and verify that the constructor signatures match. 
 This approach introduces several critical problems such as:

\begin{itemize}
    \item \textbf{No compile-time verification}: The class name is merely a string literal, 
    so there is no way to verify at configuration authoring time that the specified class exists, 
    is accessible, or implements the expected interface.
    \item \textbf{No constructor parameter validation}: The parameters array must match the constructor signature, 
    but this compatibility cannot be checked statically. 
    A mismatch between parameter count, types, or order is discovered only when instantiation fails at runtime.
    \item \textbf{No type inference or IDE support}: Since class names are strings, Integrated Development Environments (IDEs)
     cannot provide autocomplete suggestions,
     type-aware parameter hints, or navigation to class definitions.
   \item \textbf{Refactoring}: Renaming a class in the codebase requires manually updating all string references in configuration files,
     with no tooling support to ensure completeness.
\end{itemize}

This pattern of specifying class names as strings for runtime instantiation is not unique to Alchemist. 
Many frameworks employ similar approaches across different domains. 
The Spring Framework , for instance, allows developers to define beans and their dependencies in XML 
configuration files\footnote{\url{http://archive.today/p3ANv}},
 where class names are specified as strings:

\begin{minted}[fontsize=\footnotesize, linenos]{xml}
<bean id="item1" class="org.baeldung.store.ItemImpl1" /> 
<bean id="store" class="org.baeldung.store.Store"> 
    <constructor-arg type="ItemImpl1" index="0" name="item" ref="item1" /> 
</bean>
\end{minted}
\captionof{lstlisting}{Example of a Spring Framework XML configuration}

Spring's dependency injection container resolves these string class names at runtime, 
instantiating the classes and wiring dependencies. 
Moreover, when configurations involve nested object construction, 
where one class requires another class as a parameter, 
the problem compounds. 
Consider an Alchemist configuration specifying
 a time distribution that itself requires other time distribution objects:

\begin{minted}[fontsize=\footnotesize, linenos]{yaml}
time-distribution:
  type: JaktaTimeDistribution
  parameters:
    sense:
      type: WeibullTime
      parameters: [1, 1]
    deliberate:
      type: DiracComb
      parameters: 0.1
    act:
      type: ExponentialTime
      parameters: 1
\end{minted}
\captionof{lstlisting}{Example of an Alchemist YAML configuration with nested objects}

The absence of compile-time type checking means that refactoring configurations is inherently risky.
Renaming a service, changing a parameter structure, or modifying nested configurations requires manual verification 
that all references have been updated correctly. 
In complex configurations spanning multiple files or involving hundreds of interdependent components, 
this manual process is error-prone and time-consuming.
Type mismatches, missing required fields, and inconsistent parameter combinations are discovered only through runtime failures, 
forcing users to debug through opaque error messages and stack traces rather than receiving immediate, 
actionable feedback during configuration authoring.

\subsubsection{Limited Developer Experience}

The absence of type information significantly restricts the functionality of Integrated Development Environments (IDEs) and text editors. 
When explicit schemas or type specifications are missing, 
IDEs are unable to offer useful autocomplete features, embedded documentation, or immediate error identification. 
Users must depend on separate documentation to learn about available configuration parameters, expected data types, and applicable restrictions. 
This lack of IDE assistance steepens the learning process for newcomers and diminishes efficiency even among seasoned users.

Validation mechanisms based on schemas are available for JSON, YAML, and XML formats, providing a certain level of 
structural checking and enhanced IDE functionality. JSON Schema\footnote{\url{https://json-schema.org/specification}}
provides a uniform method for specifying the anticipated structure of JSON files, whereas XML Schema Definition (XSD)\footnote{\url{http://archive.today/G557h}} 
delivers comparable features for XML. YAML configurations can utilize JSON Schema or YAML-tailored schema specifications to verify document organization,
 mandatory fields, and fundamental type requirements.

Nevertheless, schema-based validation offers only incomplete remedies to the core limitations of untyped configuration formats. 
Although schemas can check syntax—confirming that mandatory fields exist, that values match expected basic types, and that document 
structure aligns with a specified template, they deliver restricted support for business logic and semantic verification.

In the case of a system that supports class loading, including Alchemist, a schema author 
could enumerate all possible class names that may appear in a \texttt{type} field, 
allowing the schema to validate that the string represents one of the known classes. Similarly, 
a schema could specify the expected parameter count and types for each enumerated class, enabling validation of constructor compatibility. 
However, this approach requires the schema author to maintain a complete, exhaustive list of all classes that may be instantiated, 
along with their constructor signatures. 
For closed systems with a fixed set of types, this is feasible and can provide meaningful validation.

The fundamental challenge arises in \textit{extensible} software systems like Alchemist, 
where the set of valid class types is open-ended and cannot be fully captured in a static schema definition. 
A schema author attempting to enumerate all possible classes would face a challenging task: 
the schema would need to be updated every time a new plugin or extension is developed, or use an 
automated tool to generate it. 

Moreover, schemas cannot validate semantic relationships that require understanding the runtime behavior of classes. 
For instance, schemas cannot ensure that YAML anchor references resolve correctly, 
that variable dependencies form a valid acyclic graph, or that mathematical expressions in configuration values
 are well-formed and type-safe. 
These validations require understanding the semantics of the configuration language and the relationships 
between configuration elements, 
which goes beyond what structural schemas can express.

These schemas are typically external to the configuration file itself and 
require explicit configuration of IDE plugins or validation tools. 
The developer experience contrasts sharply with that of statically-typed programming languages, 
where IDEs provide comprehensive autocomplete, type checking, refactoring support, 
and inline documentation based on the language's type system.

\subsubsection{Readability and Maintainability Challenges}

As configuration complexity increases, JSON and YAML files become increasingly difficult to read, 
understand, and maintain.
The hierarchical structure of these formats, while useful for simple configurations, 
becomes unwieldy when dealing with systems
 involving dozens of components, deeply nested structures, or complex interdependencies.
 It is not uncommon to see configurations with hundreds of lines of code,
  making it difficult to understand and maintain.

Another issue of untyped configuration formats is the lack of mechanisms to reduce 
duplication within a single file. Some formats do provide limited mechanisms 
to reduce duplication such as YAML that supports anchors and aliases\footnote{\url{http://archive.today/bcJbb}}
that allow defining 
a value once and referencing it multiple times within the same document. 
However, these mechanisms are fundamentally limited: they operate only within a single file, 
cannot reference external files, and provide no type safety or compile-time validation of references. 
JSON provides no built-in mechanism for reuse whatsoever, requiring complete duplication of common patterns.

More critically, none of these formats provide standardized mechanisms for dividing configurations 
across multiple files and reusing components across different configuration files, 
as one would expect in a programming language where classes and functions can be defined 
in separate modules 
and imported where needed. While XML provides standardized mechanisms for including external files 
such as \textit{XInclude}\footnote{\url{https://www.w3.org/TR/xinclude-11/}}, YAML and JSON have no such standard capabilities. 
This limitation forces users of the configuration system to either maintain monolithic configuration files 
or rely on external preprocessing tools that merge files before parsing, 
neither of which provides the type safety, IDE support, or refactoring capabilities 
that would be available if configurations could be structured as reusable, 
type-checked modules similar to programming language components. Complex applications, like
Alchemist, could benefit from this by being able
 to define reusable components that can be shared across different simulations.

The limitations of JSON and YAML formats become particularly pronounced when configuring complex 
scenarios such as scientific simulations and experimental configurations. 
Expressing complex scenarios in YAML results in very long files that tend to 
grow more vertically rather than horizontally (see listing~\ref{lst:examplecomplexsimulation}), where the  
semantic relationships between configuration elements are obscured by syntactic boilerplate. 

\begin{center}
    \begin{minipage}{0.48\textwidth}
    \inputminted[
      fontsize=\tiny,
      breaklines,
      firstline=1,
      lastline=59, 
      linenos
    ]{yaml}{listings/examplecomplexsimulation.yaml}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
    \inputminted[
      fontsize=\tiny,
      breaklines,
      firstline=60,
      lastline=119, 
      linenos
    ]{yaml}{listings/examplecomplexsimulation.yaml}
    \end{minipage}
    \captionof{lstlisting}
    {Example of a complex Alchemist simulation configuration \protect~\cite{domini2025fbfl}}
    \label{lst:examplecomplexsimulation}
\end{center}
\newpage


Parameter references must be expressed as strings, making it
impossible to verify referential integrity statically. 
Mathematical expressions and conditional logic must be encoded as strings or 
complex nested structures, losing the clarity and type safety that programming 
language constructs would provide. The lack of abstraction mechanisms
beyond simple variable substitution means that common patterns must be repeated rather 
than abstracted into reusable components.


\subsubsection{Error Handling and Runtime Validation}

As configuration systems scale to complex scenarios, the error handling and validation mechanisms 
in YAML, JSON, and XML reveal fundamental limitations that make debugging difficult and error-prone. 
Unlike statically-typed programming languages where errors are caught at compile-time with precise 
location information and clear diagnostic messages, configuration formats provide only runtime validation, 
and the error messages they produce are often ambiguous, unhelpful, or point to internal parser mechanisms 
rather than the actual configuration problem.

One of the most insidious aspects of YAML's indentation-based syntax is that a misindented line can produce 
a syntactically valid document that parses successfully, but with a completely different semantic meaning 
than intended. Consider the following Alchemist configuration:

\begin{minted}[fontsize=\footnotesize, linenos]{yaml}
incarnation: sapere
environment:
  type: Continuous2DEnvironment
  parameters: [100, 100]
network-model: {type: ConnectWithinDistance, parameters: [5]}
\end{minted}
\captionof{lstlisting}{Example of a correct Alchemist YAML configuration}

\newpage
If a single extra space is accidentally added before \texttt{network-model}, the YAML parser will interpret 
it as a nested key under \texttt{environment}:

\begin{minted}[fontsize=\footnotesize, linenos]{yaml}
incarnation: sapere
environment:
  type: Continuous2DEnvironment
  parameters: [100, 100]
  # Extra tab before this line
  network-model:  {type: ConnectWithinDistance, parameters: [5]}
\end{minted}
\captionof{lstlisting}{Example of an Alchemist YAML configuration with incorrect indentation}

This configuration is syntactically valid and will parse without error, but the \texttt{network-model} 
will be incorrectly nested under \texttt{environment} rather than being a top-level configuration key. 
In this case the application will produce two different simulation results:
\begin{itemize}
    \item The first file will produce a simulation with the specified network model (\textit{ConnectWithinDistance}).
    \item The second file will produce a simulation where the network model is ignored, and 
    the default network model is used (\textit{NoLinks}).
\end{itemize}

The user must manually inspect the file, and check indentation levels to identify the root cause,
 a time-consuming process that becomes even more difficult as configuration files 
 grow to hundreds of lines. These kinds of errors are particularly insidious because the configuration file 
 is still a valid file and the application may not always produce an error message.
The problem compounds when configurations reference values that are validated only at application runtime. 
For example, a Spring Boot beans configuration XML file might specify a class name that does not exist:

\begin{minted}[fontsize=\footnotesize, linenos]{xml}
<bean id="nonExistentBean" class="com.example.NonExistentClass">
    <property name="someProperty" value="test"/>
</bean>
\end{minted}
\captionof{lstlisting}{Example of a wrong Spring XML configuration}

The XML parser will accept this configuration as valid, since \texttt{NonExistentClass} 
is a perfectly valid string. The error will only surface when the application attempts to instantiate 
the class at runtime.
\begin{minted}[
    fontsize=\footnotesize,
    linenos
]{java}
[...]
Caused by: java.lang.ClassNotFoundException: com.example.NonExistentClass
    at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass
    at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass
[...]
\end{minted}
\captionof{lstlisting}{Example of a Spring boot runtime error message}

As configuration complexity increases, with complex nested structures and interdependent 
parameters, these error handling limitations become severe productivity bottlenecks. It is not always
immediately obvious to the user to pinpoint the root cause of the error. In this case a simple mistake in the 
fully qualified name of the class will cause a \textit{ClassNotFoundException} since the application
is not able to locate the exact position of the class in the classpath.
 This makes it difficult to debug the configuration error.
Users spend significant time debugging configuration errors
 that could be caught immediately with compile-time validation, 
clear error messages, and IDE support that highlights problems as they type. The lack of early error detection 
means that configuration errors are discovered only after the system attempts to execute, potentially after 
significant computation has already occurred or after a deployment has been initiated, making the debugging 
process even more costly and frustrating.

\newpage

\subsection{The Need for a Type-Safe Configuration Language}
Recent configuration languages demonstrate that declarativity can coexist with type safety and tooling support. 
Configuration tools like CUE\footnote{\url{https://cuelang.org/docs/}} unify data, schemas, and policies inside a single constraint system, 
enabling incremental validation,
order-independent unification, and reusable templates that reduce boilerplate.
Dhall\footnote{\url{https://docs.dhall-lang.org}} delivers a total, strongly typed language whose expressions normalize 
deterministically and can be exported to YAML or JSON
without sacrificing safety guarantees\footnote{\url{https://archive.is/uNGdr}}.


These languages are not widely adopted, but they motivate the need for a type-safe configuration language,
in the sense that they show that declarativity can coexist with type safety and tooling support.
Another good example is 
Gradle, that provides a hybrid model that combines declarative DSLs with imperative logic when needed, giving the user
the best of both worlds.
In this thesis we propose a type-safe configuration language for the Alchemist simulator, using Kotlin as the implementation 
language.


The need for a type-safe configuration language is motivated by the limitations of the current YAML-based configuration system, 
as described in the previous section, and by the requirement for a more powerful configuration mechanism that can accommodate 
the extensibility of the Alchemist simulator and the complex scenarios it enables. 
Kotlin was chosen for several reasons: 
first, the language provides first-class support for building domain-specific languages through its expressive DSL builders 
and extension functions that enable creating fluent, readable configuration APIs. 
Second, Alchemist is a JVM-based framework originally implemented in Java, Kotlin, and Scala, 
which means Kotlin is already natively supported within the Alchemist ecosystem without requiring additional runtime dependencies 
or cross-language interoperability layers.
 This native integration ensures seamless compatibility with existing Alchemist codebases 
and enables direct access to the framework's APIs and domain models. 


Kotlin's static type system, combined with its DSL capabilities and IDE ecosystem, makes it possible to encode domain 
entities and relationships as first-class constructs that the compiler can verify. Type safety is therefore elevated from 
an ergonomic preference to a correctness requirement: configuration authors receive compile-time diagnostics, 
refactoring support, 
and reusable libraries that can be shared between different projects.

\section{Background}%----------------------------------------------------------------------------------------

\label{sec:background}
%----------------------------------------------------------------------------------------

This section provides the background information for this thesis work. 
We begin by introducing the Alchemist simulator, describing what it is and how it 
is used across various application domains.
Then we give a definition for the concept of Domain-Specific Language (DSL), 
and explore more in detail the usage of Kotlin to 
build Domain-Specific Languages.


\subsection{Alchemist}

Alchemist is a general-purpose simulation framework designed for modeling
 spatially-distributed systems with temporal dynamics. 
The project originated in 2010 as part of the European SAPERE\footnote{\url{https://archive.is/umlcC}} project (Self-Aware Pervasive Service Ecosystems), 
initially conceived as a chemical-oriented multi-compartment 
stochastic simulation engine capable of supporting compartment mobility 
while maintaining high performance, adopting an extended version of the 
\textit{Gibson and Bruck's Next Reaction Method}~\cite{bruck}, that is able to support 
diﬀerent rules (reactions) in diﬀerent compartments~\cite{alchemisttutorial}. Since its inception, 
Alchemist has evolved into a comprehensive simulation platform that 
transcends its original chemical domain, 
enabling researchers to model diverse phenomena 
ranging from biochemical networks to distributed computing systems, 
crowd dynamics, and swarm robotics.

What distinguishes Alchemist from domain-specific simulators is its extensible \textit{meta-model} architecture. 
Rather than being constrained to a single application domain, the framework 
employs a loose interpretation of its core abstractions, 
enabling different \emph{incarnations} to specialize the framework for specific domains 
while maintaining a unified simulation engine. 
This design philosophy allows Alchemist to serve as a versatile platform
 where domain experts can focus on their specific modeling needs 
without reimplementing core simulation infrastructure.

The simulation engine is incarnation-agnostic, 
while domain-specific functionality is encapsulated within incarnations that can be developed
 and extended independently.
 Alchemist simulations are configured via YAML files, 
 following a YAML specification \footnote{\url{https://alchemistsimulator.github.io/reference/yaml/index.html}}.
 The configuration system is very extensible and allows to configure the simulation in a very flexible way, 
 allowing the user to have full control over the simulation configuration.
 However, it suffers from fundamental YAML-based configuration limitations, 
 described in the previous section, that become increasingly problematic as simulation 
 complexity grows.


\subsubsection{Core Concepts and Meta-Model}

Alchemist's meta-model provides a unified abstraction
for modeling spatially-distributed systems through a chemical-inspired computational paradigm. 
The framework's core abstractions enable the simulation of diverse phenomena 
while maintaining a consistent conceptual model. 
Figure~\ref{fig:alchemist-metamodel} illustrates the relationships between the main entities of the Alchemist meta-model.

\begin{figure}[H]
    \makebox[\textwidth][c]{\includesvg[width=420pt]{figures/meta}}
    \caption{The Alchemist meta-model~\cite{alchemisttutorial}}
    \label{fig:alchemist-metamodel}
\end{figure}

The meta-model is organized around the following fundamental concepts:

\begin{itemize}
    \item \textbf{Data representation}:
    \begin{itemize}
        \item \emph{Molecules}: Identifiers for data items, analogous to variable names in imperative programming languages.
         A molecule serves as a key that uniquely identifies a piece of information within a node.
        \item \emph{Concentrations}: Values associated with particular molecules, similar to values stored in variables. 
        The terminology derives from chemistry but applies generically: 
        molecules and concentrations can represent any data type, enabling the framework to model diverse 
        domains beyond chemical systems. 
        The loose interpretation of these concepts is fundamental to Alchemist's extensibility, 
        as different incarnations can define concentration types appropriate for their specific domain.
    \end{itemize}
    
    \item \textbf{Spatial organization}:
    \begin{itemize}
        \item \emph{Nodes}: Containers that hold molecules and reactions, representing entities within the simulated system. 
        Each node maintains local state through its molecules and executes reactions that modify this state over time.
        \item \emph{Environments}: Provide spatial services essential for modeling distributed systems. 
        The environment tracks node positions, computes distances between nodes, and optionally supports node mobility. 
        Environments may be continuous, representing Euclidean spaces with real-valued coordinates, or discrete, 
        representing graphs or grids. This flexibility accommodates different spatial modeling needs,
         from continuous physical spaces to discrete network topologies.
        \item \emph{Linking rules}: Functions that determine connectivity between nodes based on the current state of 
        the environment. 
        Each linking rule maps nodes to \textit{neighborhoods}, where a neighborhood consists of a center node and a set of 
        neighboring nodes. 
        This mechanism models communication constraints and interaction patterns, 
        such as distance-limited wireless networks where nodes interact only with nearby neighbors. 
        The linking rule dynamically updates neighborhoods as nodes move or as the environment changes, 
        enabling the simulation of mobile systems with evolving connectivity patterns.
        \item \emph{Neighborhoods}: Entities composed of a center node and its set of neighboring nodes, representing the local interaction context for each node.
    \end{itemize}
    
    \item \textbf{Behavioral specification}:
    \begin{itemize}
        \item \emph{Reactions}: Define the behavior and evolution of the system. 
        Each reaction comprises three essential components:
        \begin{itemize}
            \item \emph{Conditions}: Functions that evaluate the current environment state and 
            determine whether the reaction can execute.
            If a condition does not hold, the associated reaction cannot run.
            \item \emph{Actions}: Operations that modify the environment when the reaction fires, 
            changing molecule concentrations, node positions, or other system state.
            \item \emph{Time distribution}: Determines when reactions occur based on an instantaneous rate computed 
            from static parameters and condition values. 
            This stochastic modeling approach enables reactions to occur with probabilities 
            that depend on the current system state, creating realistic temporal dynamics where reaction
             frequencies adapt to environmental conditions.
        \end{itemize}
        The reaction mechanism enables the expression of complex behaviors through composition. 
        Multiple conditions can be combined to create sophisticated reaction rules, while actions can modify multiple
         molecules simultaneously or trigger cascading effects. 
         The time distribution can model various stochastic processes, 
         from exponential distributions for memoryless events to more complex distributions that capture 
         domain-specific timing characteristics.
    \end{itemize}

As previously noted, the framework includes several built-in \textit{incarnations}, each tailored to specific application domains.
Each incarnation defines type systems for concentrations and specializes the framework for specific domains.
It provides a concrete instantiation of the Alchemist meta-model by specifying the data 
types that concentrations can assume and providing domain-specific conditions, actions, environments, 
and reactions that operate on those types. 
Some of the built-in incarnations are:
    \item \textbf{SAPERE incarnation}: The initial stable incarnation developed within the European 
    SAPERE project. 
    It introduces \emph{Live Semantic Annotation} (LSA), dynamic representations of resource state
     (sensors, services, actuators).
     In Alchemist, LSAs are implemented as tuples through \texttt{LsaMolecule}, 
    stored as node data. Their evolution follows \emph{Eco-Laws}, rewriting rules similar to chemical 
    reactions that 
    consume matching tuples and produce new ones, creating ecosystem-like behaviors\footnote{\url{https://alchemistsimulator.github.io/explanation/sapere/index.html}}.
    \item \textbf{Protelis incarnation}: Integrates the Protelis~\cite{protelis} aggregate programming language,
    enabling the simulation of distributed algorithms where computations emerge from local interactions between nodes.
    \item \textbf{Scafi incarnation}: Supports the ScaFi~\cite{scafi} framework for field-based computing, 
    providing similar capabilities for aggregate programming scenarios.
    \item \textbf{Biochemistry incarnation}: Provides detailed biochemical reaction modeling capabilities, 
    supporting reactions that occur within cells, between cells, and between cells and their environment, 
    including support for cell junctions and collisions.
\end{itemize}

This incarnation-based architecture enables a unified simulation engine 
to support multiple modeling paradigms while 
allowing researchers to extend the framework with custom incarnations for specialized domains.

\subsubsection{Application Domains}

Alchemist has been employed to simulate complex scenarios across multiple domains, 
demonstrating the framework's versatility and effectiveness. Some of them are:

\begin{itemize}
    \item \textbf{Biochemical reaction networks}: Modeling the dynamics of chemical reactions in biological systems,
     where molecules represent chemical species and reactions model biochemical processes. 
    These simulations enable researchers to understand how complex biochemical networks behave under 
    different conditions and parameter settings~\cite{inbook}.

    \item \textbf{Aggregate programming systems}: Simulating field-based computing paradigms where computations
     emerge from local interactions between nodes. 
    The framework supports incarnations for Protelis and ScaFi, enabling the simulation of aggregate programming
     algorithms in realistic spatial scenarios~\cite{aggregateexample}.
    
    \item \textbf{Crowd dynamics}: Modeling the movement and behavior of crowds in various environments. 
    The spatial distribution of individuals and their local interactions create emergent behaviors that can be 
    studied through simulation\footnote{\url{https://alchemistsimulator.github.io/showcase/2022-turin/index.html}}.
    
    \item \textbf{Swarm robotics}: Modeling the collective behavior of robotic swarms where individual robots interact
     locally to achieve global objectives. 
    The framework enables the study of how local interactions give rise to coordinated swarm behaviors~\cite{swarmprogramming}.
\end{itemize}

These diverse applications demonstrate Alchemist's capability to model complex scenarios
where spatial distribution,
temporal dynamics, and stochastic interactions play crucial roles. 

\subsection{Domain Specific Languages}
\label{subsec:dsl}

A Domain-Specific Language (DSL) is a computer programming language of 
limited expressiveness focused on a particular domain~\cite{fowler2010domain}.
Unlike General-Purpose Languages (GPLs) such as Java, C++, or Kotlin, 
which are designed to be applicable across a broad range of application domains,
 DSLs are specialized tools tailored to a specific problem space.
The fundamental premise of a DSL is to provide a notation 
that allows domain experts to express solutions in terms of domain
 \emph{concepts} rather than programming constructs.
By raising the level of abstraction, DSLs enable users to focus on \textit{what} 
to compute rather than \textit{how} to compute it, 
bridging the semantic gap between the problem domain and the implementation.

The development and adoption of DSLs are driven by several key advantages.
First, they offer improved \textbf{productivity} and \textbf{reliability} within their specific domain.
Because the language constructs align directly with domain concepts, 
programs written in a DSL are typically more concise and self-documenting 
than their GPL equivalents.
This conciseness reduces the cognitive load on developers and minimizes the likelihood 
of lower-level implementation errors.
Second, DSLs are concise, can enhance maintainability, and they also allow 
for validation and optimization at the domain level~\cite{vandeursen2000dsl}.
However, designing and implementing a DSL requires significant effort and specialized skills.
There is also a learning curve associated with any new language, 
and the tooling support (IDEs, debuggers, testing frameworks) for a custom DSL 
typically lags behind that of established GPLs unless significant
 investment is made~\cite{mernik2005when}.

DSLs are generally classified into two primary 
categories based on their implementation approach: \textbf{external} and \textbf{internal} DSLs.

\subsubsection{External DSLs}

An external DSL is a language that has its own custom syntax and is
 parsed independently of the host language used to implement 
the application.
Common examples include SQL for database queries, CSS for styling web pages, 
and Regular Expressions for text matching.
Because external DSLs are not constrained by the syntax of an existing programming language,
 their designers have complete 
freedom to define a notation that best fits the domain.
This allows for highly expressive and readable
 syntaxes that can be optimized for domain experts who may not be programmers.

A prevalent subset of external DSLs adopts standard data serialization formats, 
such as XML, JSON, or YAML, as their concrete syntax.
In this approach, the DSL designer defines a schema and a set of semantic rules 
that interpret the data structure as executable logic.
This strategy eliminates the need to implement a custom lexer and parser, as robust
 libraries for these formats are available in virtually all programming environments.
Tools like Ansible (using YAML), Kubernetes (using YAML/JSON), and Maven (using XML) 
exemplify this pattern.
However, relying on a generic data format imposes significant constraints: the DSL is 
limited to the syntactic primitives of the format (e.g., key-value pairs, lists, scalars),
 often lacking native support for control flow, variables, or type checking.
As discussed in the context of Alchemist's current configuration, this can lead 
to verbose files and runtime errors that are
difficult to diagnose.

However, for custom external DSLs, the freedom of syntax comes at a cost.
Implementing a fully custom external DSL requires building a full language infrastructure, including a lexer, parser, 
and interpreter or code generator.
Furthermore, integrating an external DSL with the host application can be complex, often requiring a bridge that maps
 the DSL's abstract syntax tree (AST) to the host language's objects.
Tooling support is another significant challenge; features like syntax highlighting, code completion, and refactoring 
support must be built from scratch, which is a non-trivial undertaking.

\subsubsection{Internal DSLs}

An internal DSL (also known as an \textit{embedded DSL}) is implemented within an existing host General-Purpose Language.
It leverages the syntax and semantics of the host language to create a specialized API that feels like a custom language.
Examples include the Gradle build system, Ruby on Rails' Active Record\footnote{\url{https://guides.rubyonrails.org/active_record_migrations.html}}, and many testing
 frameworks like ScalaTest\footnote{\url{https://www.scalatest.org/}} or Kotest\footnote{\url{https://kotest.io/docs/framework/framework.html}}.

Internal DSLs trade syntactic freedom for implementation simplicity and tooling support.
Since they are valid programs in the host language, they automatically benefit from the existing compiler,
 parser, and tooling ecosystem.
Users get autocomplete, refactoring, and debugging capabilities \emph{for free}.
Interaction with the rest of the application is seamless, as the DSL constructs are simply objects and functions in the host language.
The primary limitation is that the DSL must conform to the syntax rules of the host language.
Braces, parentheses, and keyword restrictions of the host language cannot be violated, which may result in a syntax 
that is slightly more \textit{noisy} than a pure external DSL.
However, modern languages with flexible syntax features, such as Ruby, Scala, and Kotlin, have made it possible to 
create internal DSLs that are remarkably clean and expressive.


In the context of this thesis, the choice of an internal DSL hosted in Kotlin represents a strategic balance since
it avoids the heavy burden of maintaining a custom parser and IDE plugin while delivering a type-safe,
 tool-friendly configuration experience.
Furthermore, this choice is strongly motivated by the architectural history of the Alchemist simulator.
Originally built in Java and subsequently evolved to include components in Kotlin and Scala,
 Alchemist is a polyglot framework that runs on the Java Virtual Machine (JVM).
Kotlin's designed-in interoperability with Java and other JVM languages ensures that the DSL 
can seamlessly integrate with the existing simulation engine, 
creating a unified ecosystem without the need for complex bridge layers or adapters.

\subsection{Kotlin DSLs}
\label{subsec:kotlin-dsls}

Kotlin has emerged as a premier language for developing internal DSLs on the JVM, primarily due to its flexible syntax
and specific language features designed to support type-safe builders\footnote{\url{https://kotlinlang.org/docs/type-safe-builders.html}}.
The language's design philosophy prioritizes readability and conciseness, allowing developers to create APIs that
 closely resemble natural language or declarative specifications.
This capability has led to the widespread adoption of Kotlin DSLs across the ecosystem.
Prominent examples include the Gradle Kotlin DSL\footnote{\url{https://docs.gradle.org/current/kotlin-dsl/index.html}} for build automation, 
Ktor\footnote{\url{https://ktor.io/docs/server-html-dsl.html}} for asynchronous web applications, 
and Jetpack Compose\footnote{\url{https://developer.android.com/develop/ui/compose/kotlin}} for Android UI development.
These frameworks demonstrate how Kotlin can transform 
complex configuration and logic definition tasks into type-safe, readable code structures.

The power of Kotlin for DSL construction rests on several key language mechanisms 
that work in concert to hide implementation details and expose a clean, declarative surface syntax.

\subsubsection{Lambdas with Receivers}

The cornerstone of Kotlin DSLs is the concept of \textit{lambdas with receivers}\footnote{\url{https://kotlinlang.org/docs/lambdas.html\#function-literals-with-receiver}}.
In standard lambda expressions, the context (the \texttt{this} reference) is inherited from the surrounding scope.
However, Kotlin allows defining a lambda type that has an associated receiver type, denoted as \texttt{ReceiverType.() -> Unit}.
Inside such a lambda, the client code can call methods of the receiver object directly, without any qualifier.
This feature enables the creation of hierarchical, builder-style APIs where nested blocks correspond to nested objects
 in the configuration structure.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
class HTML {
    fun body() { ... }
}

fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()  // create the receiver object
    html.init()        // pass the receiver object to the lambda
    return html
}

html {       // lambda with receiver begins here
    body()   // calling a method on the receiver object
}
\end{minted}
\captionof{lstlisting}{Example of a simple HTML builder DSL}

In this example, the \texttt{body} function is a member of the \texttt{HTML} class, 
but it appears as a top-level keyword within the \texttt{html} block.
This mechanism mimics the structure of markup languages while retaining full Turing-complete
 capabilities for variables, loops, and conditionals. 
By combining lambdas with receivers and the type system, Kotlin enables \textit{type-safe builders}.

\subsubsection{Trailing Lambdas}

Kotlin allows a lambda expression to be moved outside the parentheses if it is the last argument of a function call.
If the lambda is the \textit{only} argument, the parentheses can be omitted entirely\footnote{\url{https://kotlinlang.org/docs/lambdas.html\#passing-trailing-lambdas}}.
This syntactic sugar is crucial for DSL readability, as it eliminates the visual noise of 
nested parentheses and makes function calls look like built-in language control structures or blocks.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
// Function definition taking a lambda as the last parameter
fun repeat(times: Int, action: (Int) -> Unit) { ... }

// Usage with trailing lambda syntax
repeat(3) { index ->
    println("Iteration $index")
}
\end{minted}
\captionof{lstlisting}{Example of trailing lambda syntax}

\subsubsection{Extension Functions}

Extension functions allow adding new functionality to existing classes without inheriting 
from them or using design patterns like Decorator\footnote{\url{https://kotlinlang.org/docs/extensions.html}}.
In the context of DSLs, they enable the augmentation of third-party classes or core library
types with domain-specific convenience methods, further integrating the DSL vocabulary with the underlying domain model.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
// Extension property to create time durations from Integers
val Int.seconds: Duration
    get() = Duration.ofSeconds(this.toLong())

// Usage within the DSL
environment {
    timeout = 10.seconds 
}
\end{minted}
\captionof{lstlisting}{Using extension properties to add domain-specific syntax to primitive types}

\subsubsection{Context Parameters}

A recent evolution in Kotlin's design is the introduction of \textit{context parameters}\footnote{\url{https://kotlinlang.org/docs/context-parameters.html}}.
This feature allows functions to declare dependencies on multiple contexts simultaneously, 
without requiring deeply nested wrapping objects.
For DSLs, this promises even more expressive power,
 allowing a configuration block to depend on multiple environmental 
 capabilities implicitly, simplifying the architecture of complex DSLs where components need access to shared services.

\subsection{Kotlin Symbol Processing}
\label{subsec:ksp}

Usability and readability are critical success factors for any Domain-Specific Language.
To achieve a high level of usability in the Alchemist DSL, this thesis leverages advanced metaprogramming 
techniques to generate supporting structures and validation logic automatically.
A key technology enabling this approach is \textit{Kotlin Symbol Processing} (KSP)\footnote{\url{https://kotlinlang.org/docs/ksp-overview.html}}.

KSP is a compiler plugin API developed by Google that provides a simplified 
and powerful way to analyze Kotlin code at compile time.
It allows build tools to parse Kotlin source code,
 inspect symbols (such as classes, functions, properties, and annotations), 
 and generate new Kotlin code based on this analysis.

The working mechanism of KSP is as follows:
\begin{enumerate}
    \item \textbf{Analysis}: The KSP processor runs during the compilation phase, 
    scanning the user's source code to find specific annotations or code patterns.
    \item \textbf{Processing}: It builds a model of the code structure (symbol table) 
    that represents the types, names, and relationships in the codebase.
    \item \textbf{Generation}: Based on this model, the processor generates new source files 
    (e.g., extension functions, helper classes, or validation routines) that are automatically 
    compiled and added to the project's classpath.
\end{enumerate}

In the context of this thesis, KSP is utilized to bridge the gap between the complex Alchemist core APIs and 
the user-friendly DSL surface syntax.
Specifically, it automates the generation of helper functions that wrap existing Alchemist model classes.
These generated helpers simplify object instantiation by abstracting away the complexity of native constructors, 
which often require numerous parameters.
Instead of forcing the user to supply every dependency manually, 
the generated code automatically detects and injects the necessary parameters from the surrounding DSL context.
This approach ensures that the DSL remains concise and easy to use while staying in sync with the underlying simulation engine.
The detailed implementation of this mechanism will be discussed in Chapter~\ref{chap:implementation}.

