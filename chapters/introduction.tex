%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

The simulation of complex systems has become a fundamental tool in modern scientific research and engineering practice. 
Complex systems are characterized by the interaction of numerous components that give rise to emergent behaviors that cannot be easily predicted from the individual components alone. 
These systems span diverse domains, from biological networks and chemical reactions to distributed computing systems, social dynamics, and swarm robotics. 
Understanding and predicting the behavior of such systems requires sophisticated simulation frameworks capable of modeling spatial distributions, temporal dynamics, and stochastic interactions.

Alchemist is a simulation framework designed to address these challenges by providing a powerful platform for modeling spatially-distributed systems with temporal dynamics. 
However, as the complexity of simulated systems increases, the current YAML-based configuration system presents significant challenges that limit productivity and reliability. 
This thesis addresses these limitations by developing a type-safe Domain-Specific Language (DSL) in Kotlin for Alchemist configuration. 
The DSL leverages Kotlin's type system and IDE support to provide compile-time error detection, autocomplete capabilities, and improved developer experience, while maintaining semantic equivalence with the existing YAML configuration system.

The remainder of this thesis is organized as follows. 
Chapter~\ref{chap:background} provides background information on Alchemist, including its application domains, use cases, and the motivation that led to this work. 
Chapter~\ref{chap:analysis} analyzes the requirements and constraints for developing the DSL, examining the limitations of the current YAML approach and establishing the domain model. 
Chapter~\ref{chap:design} presents the design of the DSL, including its architecture and key design decisions. 
Chapter~\ref{chap:implementation} describes the implementation details and challenges encountered during development. 
Chapter~\ref{chap:evaluation} evaluates the DSL through case studies and comparison with YAML configurations. 
Finally, Chapter~\ref{chap:conclusion} summarizes the contributions and discusses future work.
\section{Context and Motivation}
\subsection{Configuring Complex Systems}

\subsubsection{Configuration as a Fundamental Mechanism}

Configuration constitutes a fundamental mechanism through
 which users specify the structure, behavior, and parameters
  of complex systems without modifying the underlying implementation. 
  In the context of computational systems, configuration encompasses 
  the specification of runtime characteristics, architectural topology,
   behavioral policies, and experimental parameters that govern system
    execution. Rather than encoding these aspects directly into program 
    logic, configurations externalize them into separate artifacts that 
    can be modified, versioned, and reused independently of the core 
    codebase. This separation of concerns enables a single implementation 
    to serve diverse use cases through different configurations.
    For example, in a simulation framework like Alchemist (add citation) a simulation
    can be defined by creating a configuration file that specifies the 
    all the needed parameters such as the initial state and the behavior of its components.
    This configuration file can then be used to create a simulation instance that can be run.

    

\subsubsection{Imperative and Declarative Configuration Paradigms}

Configuration management systems can be classified according to 
two distinct paradigms that fundamentally differ in their approach 
to system specification and manipulation: 
\begin{itemize}
    \item \textbf{Imperative paradigm}
    \item \textbf{Declarative paradigm}
\end{itemize}

This distinction, 
 rooted in the dichotomy between procedural and declarative 
 programming models, has profound implications for how 
 systems are configured, maintained, and reasoned about.

The \textit{imperative configuration} paradigm focuses on specifying \textbf{how} 
a system should reach its desired state through explicit sequences of 
commands and operations. An imperative configuration defines 
the procedural \textbf{steps} required to transform the system from its 
current state to the target state. Each command represents an 
action that modifies system state, and the execution order is 
critical to achieve the intended outcome. Shell scripts, 
deployment automation tools like Ansible in its command-based mode 
and traditional system administration procedures exemplify this approach.
An example of an imperative configuration is \textit{Dockerfile} configuration file:
Docker is an open platform for developing, shipping, and running applications (citation)
A \textit{Dockerfile} is the Docker's imperative configuration 
format for building container images. 
It is a text file containing instructions for building source code. 

\begin{minted}{dockerfile}
FROM ubuntu:22.04

# install app dependencies
RUN apt-get update && apt-get install -y python3 python3-pip
RUN pip install flask==3.0.*

# install app
COPY hello.py /

# final configuration
ENV FLASK_APP=hello
EXPOSE 8000
CMD ["flask", "run", "--host", "0.0.0.0", "--port", "8000"]
\end{minted}

In this example, each \texttt{RUN}, \texttt{COPY}, and \texttt{CMD} instruction represents
 a step that modifies the container image state, 
 and the sequence must be carefully ordered 
 (e.g., installing packages before executing files that depend on them). 
 Docker then, builds images by reading the instructions from a Dockerfile.

In contrast, the declarative configuration paradigm focuses 
on specifying \textbf{what} the desired system state should be,
 abstracting away the procedural details of how that state is achieved. 
 A declarative configuration describes the target state as a set
  of constraints, properties, and resource specifications, 
  delegating to the configuration management 
  system the responsibility of determining and executing the
   necessary operations to realize that state. 
   The system automatically computes the necessary
   set of changes required to achieve the desired state. 
    Tools such as Puppet, Terraform, Kubernetes manifests, 
    and Docker Compose exemplify this paradigm. 
    Docker Compose, for example, allows developers to declare 
    the desired state of multi-container applications:
\begin{minted}{yaml}
services:
  web:
    build: .
    ports:
      - "8000:5000"
  redis:
    image: "redis:alpine"
\end{minted}

The declarative paradigm offers several compelling advantages that have driven its
adoption across modern infrastructure management. 
\begin{enumerate}
    \item First, declarative configurations are
    inherently more readable and maintainable, as they document the intended system state
    without obscuring it with implementation details.
    \item They are idempotent by design:
    applying the same configuration multiple times produces the same result, eliminating concerns
    about partial execution or repeated application.
    \item They facilitate reasoning about system properties through formal verification
     and constraint validation before deployment.
    \item They support more robust error handling, as the system
    can detect when the desired state cannot be achieved and report specific discrepancies.
\end{enumerate}

\subsubsection{Application Domains and Representative Systems}

Declarative configuration systems have proliferated across diverse domains of software infrastructure, 
each addressing specific challenges while adhering to common architectural principles.
 Understanding these application domains and their representative technologies provides 
 context for the subsequent discussion of configuration challenges and the motivation
  for type-safe configuration approaches.

\paragraph{Infrastructure Configuration Management.}
Puppet pioneered the declarative configuration management paradigm for
 physical and virtual server infrastructure. (citation here)
  Its resource abstraction model allows administrators to declare desired states for files,
   packages, services, users, and other system entities,
    with the Puppet agent responsible for ensuring these resources match their specifications.
     Chef followed a similar philosophy while embedding configuration logic within a
      Ruby domain-specific language, providing both declarative resource declarations and 
      imperative programming constructs. 
      These tools revolutionized system administration by replacing ad-hoc shell
       scripts with version-controlled, testable configuration artefacts.

\paragraph{Cloud Infrastructure Provisioning.}
Terraform extended declarative configuration to cloud resource provisioning, 
allowing operators to declare entire cloud environments, including compute instances, 
networks, load balancers, databases, and access policies, using a unified configuration language. 
Its provider ecosystem supports virtually all major cloud platforms and services,
 enabling multi-cloud deployments through consistent declarative specifications.

\paragraph{Container Orchestration.}
Kubernetes represents perhaps the purest expression of declarative configuration in modern infrastructure.
 The Kubernetes API defines a comprehensive schema of resource type such as 
 Pods, Services, Deployments, ConfigMaps, Secrets, and dozens of others, 
 that collectively describe application topology, networking, storage, and operational policies. 
 Users express desired states through YAML or JSON manifests, and Kubernetes controllers
  continuously reconcile actual cluster state with declared specifications.

\paragraph{Application Deployment and Composition.}
Docker Compose applies declarative configuration to application deployment, 
allowing developers to specify multi-container applications as collections of services with 
defined dependencies, networking, and resource constraints. 

\paragraph{Simulation and Experiment Configuration.}
Scientific simulation frameworks like Alchemist employ 
declarative configuration
 to specify complex experimental scenarios. 
  This approach enables researchers to express sophisticated experimental 
  designs without imperative programming, facilitating reproducibility 
  and systematic parameter exploration.

These systems, while addressing distinct domains, share common architectural patterns:
\begin{itemize}
    \item{\textbf{Resource schema}}: defines the universe of entities that the configuration system can manage, 
    specifying the types of resources, their properties, validation rules, and semantic constraints.
    \item{\textbf{Concrete syntax}}: provides a human-readable, version-controllable format for expressing configurations,
    supporting necessary abstraction, parameterization, and composition. Some systems, like Puppet and Terraform, 
    provide a domain-specific languages with built-in
    abstraction primitives such as modules, variables, and iteration constructs. Others, like Kubernetes,
     define a pure data format (JSON/YAML). Different concrete syntaxes can target the same underlying resource schema.
    \item{\textbf{Configuration management engine}}: it is responsible for determining a valid sequence 
    of operations to achieve the desired state (respecting dependencies and constraints), 
    and execute those operations while handling errors and partial failures. 
\end{itemize}


\subsection{Challenges and Limitations}

Despite the architectural sophistication of declarative configuration systems,
 the concrete syntax layer has converged on a remarkably narrow set of data serialization formats. 
 XML (Extensible Markup Language), JSON (JavaScript Object Notation), YAML (YAML Ain't Markup Language) have emerged as one 
 of the most used data formats for expressing configuration artifacts across different domains of modern software infrastructure. 
 This convergence reflects their perceived advantages: 
 human readability, widespread tool support, and interoperability with programming language data structures. 
 However, these formats have fundamental limitations that become increasingly problematic as configuration complexity grows.

\subsubsection{Lack of Type Safety}

XML, JSON and YAML are fundamentally \textit{untyped} data formats. 
They represent data structures (objects, arrays, strings, numbers, booleans, and null values) without any mechanism for expressing type constraints, 
required fields, or value ranges. 
Type information exists only implicitly through runtime validation performed by the consuming application, 
which must parse the configuration and verify that values conform to expected types and constraints. 
This validation occurs entirely at runtime, meaning configuration errors surface only when the system attempts to load or execute the configuration,
 potentially after significant development effort has been invested.

Beyond the absence of type constraints, XML, JSON and YAML are fundamentally limited to primitive data types supported by 
the serialization format itself. 
These formats natively support only basic scalar types along with composite structures (objects and arrays) composed of these primitives.
This limitation becomes particularly problematic when configuration systems need to express domain-specific concepts that
 map to programming language classes, interfaces, or complex object types. 

Consider simulation frameworks like Alchemist, where configurations must specify classes that will be instantiated at runtime to
 represent domain entities. The YAML configuration expresses these class specifications as string literals:

\begin{minted}{yaml}
incarnation: protelis
environment:
  type: Continuous2DEnvironment

network-model:
  type: ConnectWithinDistance
  parameters: [6]

deployments:
  type: Rectangle
  parameters: [1, 0, 0, 100, 100]
\end{minted}

Here, class names such as \texttt{Continuous2DEnvironment}, 
\texttt{ConnectWithinDistance} and
\texttt{Rectangle} are specified as plain strings. 
The application must use reflection or factory patterns to resolve these string class 
names to actual Java or Kotlin classes at runtime, instantiate them with the provided parameters,
 and verify that the constructor signatures match. 
 This approach introduces several critical problems such as:

\begin{itemize}
    \item \textbf{No compile-time verification}: The class name is merely a string literal, 
    so there is no way to verify at configuration authoring time that the specified class exists, 
    is accessible, or implements the expected interface.
    \item \textbf{No constructor parameter validation}: The parameters array must match the constructor signature, 
    but this compatibility cannot be checked statically. 
    A mismatch between parameter count, types, or order is discovered only when instantiation fails at runtime.
    \item \textbf{No type inference or IDE support}: Since class names are strings, Integrated Development Environments (IDEs)
     cannot provide autocomplete suggestions,
     type-aware parameter hints, or navigation to class definitions.

    \item \textbf{Refactoring}: Renaming a class in the codebase requires manually updating all string references in configuration files,
     with no tooling support to ensure completeness.
\end{itemize}

This pattern of specifying class names as strings for runtime instantiation is not unique to Alchemist. 
Many frameworks employ similar approaches across different domains. 
The Spring Framework, for instance, allows developers to define beans and their dependencies in XML configuration files,
 where class names are specified as strings:

\begin{minted}{xml}
<bean id="item1" class="org.baeldung.store.ItemImpl1" /> 
<bean id="store" class="org.baeldung.store.Store"> 
    <constructor-arg type="ItemImpl1" index="0" name="item" ref="item1" /> 
</bean>
\end{minted}

Spring's dependency injection container resolves these string class names at runtime, 
instantiating the classes and wiring dependencies. 
Moreover, when configurations involve nested object construction, 
where one class requires another class as a parameter, 
the problem compounds. 
Consider an Alchemist configuration specifying a time distribution that itself requires other time distribution objects:

\begin{verbatim}
time-distribution:
  type: JaktaTimeDistribution
  parameters:
    sense:
      type: WeibullTime
      parameters: [1, 1]
    deliberate:
      type: DiracComb
      parameters: 0.1
    act:
      type: ExponentialTime
      parameters: 1
\end{verbatim}

The absence of compile-time type checking means that refactoring configurations is inherently risky.
 Renaming a service, changing a parameter structure, or modifying nested configurations requires manual verification 
 that all references have been updated correctly. 
 In complex configurations spanning multiple files or involving hundreds of interdependent components, 
 this manual process is error-prone and time-consuming.
 Type mismatches, missing required fields, and inconsistent parameter combinations are discovered only through runtime failures, 
 forcing practitioners to debug through opaque error messages and stack traces rather than receiving immediate, 
 actionable feedback during configuration authoring.

\subsubsection{Limited Developer Experience}

The lack of type information severely limits the capabilities of Integrated Development Environments (IDEs) and text editors.
Without explicit schemas or type definitions, IDEs cannot provide meaningful autocomplete suggestions, 
inline documentation, or real-time error detection. 
Developers must rely on external documentation to understand what configuration options are available,
 what types are expected, and what constraints apply. 
 This absence of IDE support increases the learning curve for new users and reduces productivity even for experienced practitioners.

Schema validation mechanisms exist for JSON, YAML, and XML formats, 
offering some degree of structural validation and improved IDE support.
 JSON Schema (citation here) provides a standardized way to define the expected structure of JSON documents, 
 while XML Schema Definition (XSD)(citation here) offers similar capabilities for XML. YAML configurations can leverage JSON Schema or
  YAML-specific schema definitions to validate document structure, required fields, and basic type constraints.

However, schema validation provides only partial solutions to the fundamental limitations of untyped configuration formats.
 While schemas can validate \emph{syntax}, ensuring that required fields are present, that values conform to expected primitive types,
  and that the document structure matches a defined pattern, they provide limited support for \emph{domain logic} and \emph{semantic validation}. 

In principle, a schema author could enumerate all possible class names that may appear in a \texttt{type} field, 
allowing the schema to validate that the string represents one of the known classes. Similarly, 
a schema could specify the expected parameter count and types for each enumerated class, enabling validation of constructor compatibility. 
However, this approach requires the schema author to maintain a complete, exhaustive list of all classes that may be instantiated, 
along with their constructor signatures. For closed systems with a fixed set of types, this is feasible and can provide meaningful validation.

The fundamental challenge arises in extensible software systems like Alchemist, 
where the framework's plugin architecture allows users to define custom incarnations, environments, network models, and reaction types. 
In such systems, the set of valid class types is open-ended and cannot be fully captured in a static schema definition. 
A schema author attempting to enumerate all possible classes would face an insurmountable task: 
the schema would need to be updated every time a new plugin or extension is developed, 
and it would still fail to validate configurations that use custom classes unknown to the schema at the time of schema definition. 
Even if a schema were maintained to include all built-in classes, configurations using user-defined custom classes would remain unvalidated, 
defeating the purpose of comprehensive validation.

Moreover, schemas cannot validate semantic relationships that require understanding the runtime behavior of classes. 
For instance, schemas cannot ensure that YAML anchor(citation here) references resolve correctly, 
that variable dependencies form a valid acyclic graph, or that mathematical expressions in configuration values are well-formed and type-safe. 
These validations require understanding the semantics of the configuration language and the relationships between configuration elements, 
which goes beyond what structural schemas can express.

These schemas are typically external to the configuration file itself and 
require explicit configuration of IDE plugins or validation tools. 
The developer experience contrasts sharply with that of statically-typed programming languages, 
 where IDEs provide comprehensive autocomplete, type checking, refactoring support, and inline documentation based on the language's type system.

\subsubsection{Readability and Maintainability Challenges}

As configuration complexity increases, JSON and YAML files become increasingly difficult to read, 
understand, and maintain.
The hierarchical structure of these formats, while useful for simple configurations, 
becomes unwieldy when dealing with systems
 involving dozens of components, deeply nested structures, or complex interdependencies.
 It is not uncommon to see configurations with hundreds of lines of code,
  making it difficult to understand.

Another issue of untyped configuration formats is the lack of mechanisms to reduce 
duplication within a single file. Some formats do provide limited mechanisms 
to reduce duplication such as YAML that supports anchors and aliases (\texttt{\&anchor} 
and \texttt{*alias}) (citation here) 
that allow defining 
a value once and referencing it multiple times within the same document. 
However, these mechanisms are fundamentally limited: they operate only within a single file, 
cannot reference external files, and provide no type safety or compile-time validation of references. 
JSON provides no built-in mechanism for reuse whatsoever, requiring complete duplication of common patterns.

More critically, none of these formats provide standardized mechanisms for dividing configurations 
across multiple files and reusing components across different configuration files, 
as one would expect in a programming language where classes and functions can be defined 
in separate modules 
and imported where needed. While XML provides standardized mechanisms for including external files 
(such as XInclude)(citation here), YAML and JSON have no such standard capabilities. 
Some tools provide non-standard include mechanisms (e.g., Ansible's \texttt{!include} directive)(citation here), 
but these are tool-specific, non-portable, and lack compile-time validation. 
This limitation forces users of the configuration system to either maintain monolithic configuration files 
or rely on external preprocessing tools that merge files before parsing, 
neither of which provides the type safety, IDE support, or refactoring capabilities 
that would be available if configurations could be structured as reusable, 
type-checked modules similar to programming language components. The limitations of JSON and YAML become particularly pronounced when configuring complex 
scenarios such as scientific simulations and experimental configurations. 
Expressing complex scenarios in YAML results in very long files that tends to 
grow more vertically than horizontally, where the  
semantic relationships between configuration elements are obscured by syntactic boilerplate. 


\noindent
\begin{center}
    \begin{minipage}{0.48\textwidth}
    \inputminted[
      fontsize=\tiny,
      breaklines,
      frame=lines,
      firstline=1,
      lastline=59
    ]{yaml}{listings/examplecomplexsimulation.yaml}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
    \inputminted[
      fontsize=\tiny,
      breaklines,
      frame=lines,
      firstline=60,
      lastline=119
    ]{yaml}{listings/examplecomplexsimulation.yaml}
    \end{minipage}
\end{center}
\newpage


Parameter references must be expressed as strings, making it
 impossible to verify referential integrity statically. 
 Mathematical expressions and conditional logic must be encoded as strings or 
 complex nested structures, losing the clarity and type safety that programming 
 language constructs would provide. The lack of abstraction mechanisms
  beyond simple variable substitution means that common patterns must be repeated rather 
  than abstracted into reusable components.


\subsubsection{Error Handling and Runtime Validation}

As configuration systems scale to complex scenarios, the error handling and validation mechanisms 
in YAML, JSON, and XML reveal fundamental limitations that make debugging difficult and error-prone. 
Unlike statically-typed programming languages where errors are caught at compile-time with precise 
location information and clear diagnostic messages, configuration formats provide only runtime validation, 
and the error messages they produce are often ambiguous, unhelpful, or point to internal parser mechanisms 
rather than the actual configuration problem.

One of the most insidious aspects of YAML's indentation-based syntax is that a misindented line can produce 
a syntactically valid document that parses successfully, but with a completely different semantic meaning 
than intended. Consider the following Alchemist configuration:

\begin{minted}{yaml}
incarnation: sapere
environment:
  type: Continuous2DEnvironment
  parameters: [100, 100]
network-model: {type: ConnectWithinDistance, parameters: [5]}
\end{minted}

If a single extra space is accidentally added before \texttt{network-model}, the YAML parser will interpret 
it as a nested key under \texttt{environment}:

\begin{minted}{yaml}
incarnation: sapere
environment:
  type: Continuous2DEnvironment
  parameters: [100, 100]
  # Extra tab before this line
  network-model:  {type: ConnectWithinDistance, parameters: [5]}
\end{minted}

This configuration is syntactically valid and will parse without error, but the \texttt{network-model} 
will be incorrectly nested under \texttt{environment} rather than being a top-level configuration key. 
In this case the application will produce two different simulation results:
\begin{itemize}
    \item The first file will produce a simulation with the specified network model (\textit{ConnectWithinDistance}).
    \item The second file will produce a simulation where the network model is ignored, and 
    the default network model is used (\textit{NoLinks}).
\end{itemize}

The user must manually inspect the file, and check indentation levels to identify the root cause,
 a time-consuming process that becomes even more difficult as configuration files 
 grow to hundreds or thousands of lines. These kinds of errors are particularly insidious because they are not
  detected until the simulation is executed, potentially after significant computation has already occurred.
The problem compounds when configurations reference values that are validated only at application runtime. 
For example, an Alchemist configuration might specify a class name that does not exist:

\begin{minted}{yaml}
environment:
  type: NonExistentEnvironmentClass
  parameters: [100, 100]
\end{minted}

The YAML parser will accept this configuration as valid, since \texttt{NonExistentEnvironmentClass} 
is a perfectly valid string. The error will only surface when the application attempts to instantiate 
the class at runtime.
As configuration complexity increases, with complex nested structures, and interdependent 
parameters, these error handling limitations become severe productivity bottlenecks. Practitioners spend 
significant time debugging configuration errors that could be caught immediately with compile-time validation, 
clear error messages, and IDE support that highlights problems as they type. The lack of early error detection 
means that configuration errors are discovered only after the system attempts to execute, potentially after 
significant computation has already occurred or after a deployment has been initiated, making the debugging 
process even more costly and frustrating.

\subsection{The Need for a Type-Safe Configuration Language}
Recent configuration languages demonstrate that declarativity can coexist with type safety and tooling support. 
CUE unifies data, schemas, and policies inside a single constraint system, enabling incremental validation,
order-independent unification, and reusable templates that reduce boilerplate~\cite{cue2025}.
Dhall delivers a total, strongly typed language whose expressions normalize deterministically and can be exported to YAML or JSON
without sacrificing safety guarantees~\cite{dhall2025}.
The proposed solution aims to provide a type-safe configuration language for the Alchemist simulator, using Kotlin(citation here) as the implementation 
language.
The need for a type-safe configuration language is motivated by the limitations of the current YAML-based configuration system, 
as described in the previous section, and by the requirement for a more powerful configuration mechanism that can accommodate 
the extensibility of the Alchemist simulator and the complex scenarios it enables. 

This thesis proposes a Kotlin-based Domain-Specific Language as the solution. Kotlin was selected for several reasons: 
first, the language provides first-class support for building domain-specific languages through its expressive DSL builders, 
type-safe builders, and extension functions that enable creating fluent, readable configuration APIs. 
Second, Alchemist is a JVM-based framework originally implemented in Java, Kotlin, and Scala, 
which means Kotlin is already natively supported within the Alchemist ecosystem without requiring additional runtime dependencies 
or cross-language interoperability layers. This native integration ensures seamless compatibility with existing Alchemist codebases 
and enables direct access to the framework's APIs and domain models. Unlike YAML configurations where class names must be specified 
as strings (e.g., \texttt{type: Continuous2DEnvironment}), the Kotlin DSL allows users to directly reference simulation domain 
objects and classes as first-class language constructs, eliminating the need for string-based class name resolution and enabling 
compile-time verification that the referenced classes exist and are accessible.

Kotlin's static type system, combined with its DSL capabilities and IDE ecosystem, makes it possible to encode domain 
entities and relationships as first-class constructs that the compiler can verify. Type safety is therefore elevated from 
an ergonomic preference to a correctness requirement: configuration authors receive compile-time diagnostics, refactoring support, 
and reusable libraries, while the simulator benefits from semantically sound artifacts that can be validated before execution.

\section{Background}%----------------------------------------------------------------------------------------

\label{chap:background}
%----------------------------------------------------------------------------------------

This chapter provides the background and motivation for this thesis work. 
We begin by introducing the Alchemist simulator, describing what it is and how it is used across various application domains. 
We then present concrete use cases that demonstrate the framework's capabilities and importance. 
Finally, we examine the limitations of the current configuration system and explain why these limitations motivated the development of a type-safe Domain-Specific Language, establishing the foundation for this thesis contribution.

\subsection{Alchemist}

Alchemist is a simulation framework for 
modeling spatially-distributed systems 
with temporal dynamics. 
The project originated 
in 2010 within the context of the 
European SAPERE project\footnote{Self-Aware Pervasive Service Ecosystems} 
and has since developed into a general-purpose simulation platform. 
The framework employs a chemical-inspired computational model where system evolution 
emerges from reactions occurring between entities distributed in space.

The chemical metaphor provides a natural abstraction for modeling various phenomena. 
In chemical systems, molecules react according to rules that depend on their concentrations and spatial proximity.
Alchemist adapts this model to computational settings:
nodes represent entities that contain molecules (data) with associated concentrations (values),
and reactions define how these entities interact and evolve over time. 
This approach has been applied to domains including biochemical reaction networks, 
distributed algorithms in wireless sensor networks, aggregate programming systems, crowd dynamics, epidemic spreading, and swarm robotics.

The framework implements stochastic, event-driven simulation using variants of Gillespie's algorithm, enabling efficient execution even with large numbers of mobile entities.

\subsubsection{Core Concepts and Meta-Model}

\subsubsection{Application Domains}

Alchemist has been employed to simulate complex scenarios across multiple domains, demonstrating the framework's versatility and effectiveness:

\begin{itemize}
    \item \textbf{Biochemical reaction networks}: Modeling the dynamics of chemical reactions in biological systems, where molecules represent chemical species and reactions model biochemical processes. 
    These simulations enable researchers to understand how complex biochemical networks behave under different conditions and parameter settings.
    
    \item \textbf{Distributed algorithms in wireless sensor networks}: Simulating communication protocols and distributed algorithms where nodes represent sensors that communicate within limited ranges. 
    The spatial distribution and mobility of nodes create complex interaction patterns that can be effectively modeled using Alchemist's reaction-based approach.
    
    \item \textbf{Aggregate programming systems}: Simulating field-based computing paradigms where computations emerge from local interactions between nodes. 
    The framework supports incarnations for Protelis and ScaFi, enabling the simulation of aggregate programming algorithms in realistic spatial scenarios.
    
    \item \textbf{Crowd dynamics}: Modeling the movement and behavior of crowds in various environments. 
    The spatial distribution of individuals and their local interactions create emergent behaviors that can be studied through simulation.
    
    \item \textbf{Epidemic spreading}: Simulating the spread of diseases through populations, where nodes represent individuals and reactions model infection and recovery processes. 
    The spatial distribution and mobility patterns significantly influence the epidemic dynamics.
    
    \item \textbf{Swarm robotics}: Modeling the collective behavior of robotic swarms where individual robots interact locally to achieve global objectives. 
    The framework enables the study of how local interactions give rise to coordinated swarm behaviors.
\end{itemize}

These diverse applications demonstrate Alchemist's capability to model complex systems scenarios where spatial distribution, temporal dynamics, and stochastic interactions play crucial roles. 
The framework's flexibility allows researchers to adapt the simulation model to their specific domain requirements while leveraging a unified simulation engine.

Alchemist's meta-model consists of several core abstractions. A \emph{molecule} identifies a data item, while its \emph{concentration} represents the associated value. This terminology derives from chemistry but applies generically: molecules and concentrations can represent any data type, enabling the framework to model diverse domains.

\emph{Nodes} are containers that hold molecules and reactions. Each node maintains local state through its molecules and executes reactions that modify this state. Nodes exist within an \emph{environment}, which provides spatial services including position tracking, distance computation, and optional mobility support. Environments may be continuous (Euclidean spaces) or discrete (graphs, grids), accommodating different spatial modeling needs.

\emph{Linking rules} determine connectivity between nodes based on the environment state. Each linking rule maps nodes to \emph{neighborhoods}, consisting of a center node and its neighbors. This mechanism models communication constraints, such as distance-limited wireless networks where nodes interact only with nearby neighbors.

\emph{Reactions} define system behavior. Each reaction comprises conditions, actions, and a time distribution. Conditions evaluate the environment state, returning both a boolean (enabling the reaction) and a numeric value (influencing the reaction rate). Actions modify the environment when the reaction fires. The time distribution determines reaction timing based on an instantaneous rate computed from static parameters and condition values. This enables stochastic modeling where reaction probabilities depend on current system state.


Alchemist's extensibility relies on \emph{incarnations}, which define type systems for concentrations and specialize the framework for specific domains. The SAPERE incarnation, the original implementation, treats concentrations as numeric values representing chemical amounts. The Protelis incarnation integrates the Protelis aggregate programming language for distributed algorithm simulation. The Scafi incarnation supports the ScaFi framework for field-based computing. The Biochemistry incarnation provides detailed biochemical reaction modeling capabilities. This architecture enables a unified simulation engine to support multiple modeling paradigms.


The framework implements stochastic simulation using Gillespie's algorithm and variants for event scheduling. Environments track node positions and update neighborhoods dynamically, supporting mobile entities. The implementation targets efficiency, handling simulations with thousands of nodes. A plugin-based architecture enables extensions through new incarnations, environments, and reaction types. The system includes a graphical interface for real-time visualization, supports batch execution with parameter sweeps and variable dependencies, and provides data export capabilities for post-simulation analysis.

%\section{The Need for a Type-Safe Configuration Language}

The limitations of the current YAML-based configuration system have become increasingly problematic as Alchemist is used for more complex simulations across diverse domains. 
This section examines these limitations in detail and explains why they motivated the development of a type-safe Domain-Specific Language, which constitutes the main contribution of this thesis.

%\subsection{Current Configuration System}

Alchemist simulations are currently configured via YAML files specifying the incarnation type, environment configuration, network model, node deployments, initial molecule concentrations, reaction definitions, batch simulation variables, and export settings. 
While YAML offers human readability and a relatively simple syntax for basic configurations, it suffers from fundamental limitations that become increasingly problematic as simulation complexity grows.

%\subsection{Limitations}

The YAML-based configuration system exhibits several critical limitations that hinder productivity and reliability, particularly as simulation complexity increases.

%\subsubsection{Runtime Errors}

One of the primary limitations of the YAML-based configuration system is the lack of early error detection. 
Configuration errors surface only at runtime, when the simulation is being loaded or executed. 
These runtime errors often provide opaque and difficult-to-interpret messages that make debugging challenging. 
For instance, a typo in a molecule name or an incorrect parameter type may not be detected until the simulation attempts to access that configuration, potentially after significant computation has already occurred. 
The error messages typically reference internal data structures and parsing mechanisms rather than the user's configuration, making it difficult to identify and fix the root cause of the problem.

This opacity is particularly problematic when working with complex simulations that involve numerous nodes, reactions, and dependencies. 
A single configuration error can prevent the entire simulation from running, but locating the specific error in a large YAML file can be time-consuming and frustrating. 
Researchers and practitioners lose valuable time debugging configuration issues instead of focusing on their simulation models and analysis.

%\subsubsection{Maintainability}

As the complexity of the simulated system increases, YAML configuration files become increasingly difficult to read, understand, and maintain. 
The hierarchical structure of YAML, while useful for simple configurations, becomes unwieldy when dealing with simulations that involve:

\begin{itemize}
    \item Hundreds or thousands of nodes with different initial states
    \item Multiple reaction types with complex conditions and actions
    \item Nested dependencies between variables and parameters
    \item Multiple deployment strategies and network models
    \item Complex batch simulation scenarios with interdependent variables
\end{itemize}

The indentation-based syntax of YAML, while visually structured, becomes error-prone as nesting levels increase. 
A misplaced space or incorrect indentation can completely alter the configuration's meaning, leading to subtle bugs that are difficult to detect. 
Moreover, YAML's lack of explicit type information means that developers must rely on documentation or trial-and-error to understand what types of values are expected for each configuration parameter.

When simulating complex systems, configuration files can grow to hundreds or even thousands of lines. 
In such scenarios, navigating the YAML structure, understanding relationships between different sections, and making modifications becomes increasingly challenging. 
The absence of IDE support for YAML means that developers cannot leverage features such as autocomplete, type checking, or inline documentation, further complicating the configuration process and increasing the learning curve for new users.

%\subsubsection{Type Safety}

YAML's lack of type safety means that configuration errors related to incorrect types are only discovered at runtime. 
For example, a parameter that expects a numeric value might receive a string, or a list might be provided where a single value is expected. 
These type mismatches are not detected until the configuration is parsed and used, potentially after significant development time has been invested.

The absence of compile-time validation also means that refactoring configurations is risky. 
Renaming a molecule or changing a parameter structure requires manual verification that all references have been updated correctly. 
In complex simulations with many interdependent components, this manual process is error-prone and time-consuming. 
The lack of type checking also makes it difficult to ensure consistency across large configuration files, where the same concepts may be referenced in multiple places.



These limitations directly impact the productivity and reliability of Alchemist users. 
Researchers working on complex simulations spend significant time debugging configuration errors that could be caught at compile-time. 
The lack of IDE support increases the learning curve and reduces productivity, particularly for users new to the framework. 
As Alchemist continues to be adopted for increasingly complex scenarios, these limitations become more pronounced and hinder the framework's effectiveness.

The development of a type-safe Domain-Specific Language addresses these limitations by providing compile-time error detection, IDE support with autocomplete and inline documentation, and improved maintainability through explicit typing and better tooling. 
By moving from YAML to a programming language-based configuration approach, we enable early detection of configuration errors, improve code maintainability, and provide better tooling support for complex simulation scenarios. 
This work is motivated by the need to improve the developer experience and productivity when configuring Alchemist simulations, particularly as the framework is used for increasingly complex and sophisticated scenarios.

The DSL maintains semantic equivalence with the existing YAML configuration system, ensuring that simulations configured via the DSL behave identically to their YAML counterparts. 
This compatibility allows for gradual migration and preserves the ability to use YAML configurations when appropriate, while providing a more robust alternative for complex simulation scenarios.

\subsection{Domain-Specific Languages}
\subsection{Kotlin DSLs}
\subsection{Kotlin Symbol Processing}
