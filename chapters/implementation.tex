%----------------------------------------------------------------------------------------
\chapter{Implementation}
\label{chap:implementation}
%----------------------------------------------------------------------------------------

\section{DSL Implementation} 

The implementation of the Alchemist DSL leverages the advanced features of the Kotlin language to create a type-safe, 
declarative configuration system.
The following sections detail the core mechanisms used to build the DSL, 
focusing on the builder pattern, variable management, and the integration with the Alchemist loading system.

\subsection{Builder Functions}

The declarative syntax of the Alchemist DSL relies on Kotlin's \textit{function literals with receiver}. 
This feature allows a lambda expression to adopt the scope of a specific receiver object, binding the \texttt{this} keyword within the lambda to that object.
 This enables the creation of hierarchical structures where nested blocks map to nested context objects, reflecting the domain model outlined in \Cref{chap:design}.

In the implementation, each DSL scope is backed by a specific \textit{Context} interface,
 which defines the operations and properties available within that scope. 
 For example, the \texttt{SimulationContext} interface exposes top-level configuration methods, 
 while the \texttt{DeploymentsContext} interface limits operations to those relevant to node deployment.

 \newpage 

The pattern typically involves an interface enriched with higher-order functions that accept lambdas with receivers. 
Consider the \texttt{deployments} function in the \texttt{SimulationContext} interface:

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
interface SimulationContext<T, P : Position<P>> {
    // ...
    /**
     * Configures node deployments for the simulation.
     */
    fun deployments(block: DeploymentsContext<T, P>.() -> Unit)
    // ...
}
\end{minted}
\captionof{lstlisting}{Example of DSL syntax with builder functions.}

When a user invokes \verb|deployments { ... }|, the lambda passed as the \texttt{block} argument executes with a \texttt{DeploymentsContext} instance as its receiver.
 This allows the implementation class, \texttt{SimulationContextImpl}, to instantiate the context, apply the user's configuration block, and store the result. 
 Using interfaces as receivers restricts the visibility of internal variables and methods, preventing accidental access to internal state from the DSL script.
 

 To guarantee type safety throughout the DSL, every \textit{Context} interface is defined as generic, parameterized by types \texttt{T} and \texttt{P}. 
 When constructing a simulation, the user is required to specify these types explicitly, ensuring that the type of concentration (\texttt{T}) and the position
  representation (\texttt{P}) are established up front.
 As a consequence, all operations and properties accessible within the various context interfaces are inherently generic and bound to the chosen types.
 This design ensures that, within each scope, all entities and DSL constructs consistently adhere to the type constraints specified at the root of the simulation definition.
\newpage
 \begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
val incarnation = SAPERE.incarnation<Double, Euclidean2DPosition>()
simulation(incarnation) {
    // Inside this scope and all the nested scopes, 
    // T and P must be Double and Euclidean2DPosition
    networkModel = ConnectWithinDistance(5.0)
    deployments {
        deploy(point(0.0, 0.0)){
            // ...
        }
        deploy(point(0.0, 1.0)){
            // ...
        }
    }
}
\end{minted}
\captionof{lstlisting}{Example of DSL syntax where the type parameters \texttt{T, P} are \texttt{Double} and \texttt{Euclidean2DPosition}.}


\subsection{Execution Order}
As described in the \Cref{chap:design}, execution is often deferred and stored in a list of \textit{build steps}:

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
override fun deployments(block: DeploymentsContext<T, P>.() -> Unit) {
    buildSteps.add {
        DeploymentsContextImpl(this).apply(block)
    }
}
\end{minted}
\captionof{lstlisting}{Example of \texttt{deployments} block definition.}

This pattern recurs throughout the DSL. The \texttt{DeploymentsContext} exposes a \texttt{deploy} function that accepts a \texttt{DeploymentContext} receiver, 
building a \textit{tree} of context objects that mirrors the configuration's hierarchy.

Preserving the execution order of these build steps is critical for consistent random number generation. 
The DSL script must produce a simulation model \textbf{identical} to the one generated by the YAML configuration, 
as required by the \textbf{YAML Equivalence} functional requirement (\hyperref[subsec:yaml-equivalence]{FR1}). 
To achieve this, the order of declarations in the DSL script must match the sequence of build steps in the YAML configuration.
 Any different order would alter the consumption of the random number generators, leading to different simulation results. 
 The random number generators are heavily used by the simulation model to generate model entities such as nodes, positions, reactions, etc.

In the existing implementation,
 the simulation model is created directly within the \texttt{Loader} component (see \Cref{fig:yamlLoader}).
  This results in a monolithic class responsible for the entire model's creation, which is difficult to maintain and extend.

\begin{figure}
    \centering
    \includesvg[width=0.6\textwidth]{figures/yamlLoader}
    \caption{Legacy YAML Loader Architecture 
    demonstrating the monolithic design where the entire simulation model creation logic 
    is centralized within a single Loader component.}
    \label{fig:yamlLoader}
\end{figure}

The model is built using a \textit{depth-first} traversal of the context tree. 
This ensures dependencies are resolved before moving forward. 
As shown in the example in \Cref{fig:dfsTraversal}, with two deployments, 
the system fully materializes the first before starting the second.
 Within a deployment, it iterates through the generated nodes. 
 For each node, it injects properties and contents, then attaches reaction programs, and finally adds the node to the environment. 
 This deterministic order is essential for consistency with the legacy YAML loader's random number generation.

\begin{figure}[htbp]
    \centering
    \includesvg[width=\textwidth]{figures/dfs}
    \caption{Depth-First Traversal of the Configuration Tree illustrating the deterministic order of 
    simulation model construction.}
    \label{fig:dfsTraversal}
\end{figure}

The proposed implementation addresses the \textit{monolithic class} problem by delegating responsibilities to the individual contexts, 
while preserving the necessary depth-first traversal. 
Most context implementation classes define an \textit{apply}-prefixed method (e.g., \texttt{applyToNode}), hidden from DSL users, 
which the loader uses internally to modify the simulation model.

\begin{figure}[htbp]
    \centering
    \includesvg[width=\textwidth]{figures/dslbuildsteps}
    \caption{DSL Context Delegation Flow illustrating how the DSL implementation 
    addresses the monolithic class problem by distributing responsibilities across individual context classes.}
    \label{fig:dslDelegation}
\end{figure}

By delegating creation logic, each context manages only its specific part of the simulation model. 
This approach enforces the separation of concerns and improves the code modularity.


\subsection{Scope Control via DSL Markers}

A significant challenge in the design of DSLs based on nested builder patterns is the phenomenon of \textit{scope leakage}. 
By default, Kotlin allows lambdas with receivers to access members of their enclosing scopes implicitly. 
While this behavior facilitates concise code in many scenarios, within the Alchemist configuration domain, it poses a risk of structural ambiguity.
 Without strict boundaries, a user could inadvertently invoke methods from an outer context within a nested blockâ€”for example,
  defining a \texttt{deployment} inside another \texttt{deployment}. 
  Such constructs, while syntactically valid in Kotlin, violate the semantic constraints of the simulation model.

To mitigate this risk and enforce strict structural integrity, 
the implementation leverages the \texttt{@DslMarker} meta-annotation provided by the Kotlin standard library. 
This mechanism allows for the definition of a custom annotation, \texttt{@AlchemistDsl}, which acts as a boundary for implicit receiver resolution.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
/**
 * Marker annotation for Alchemist DSL elements.
 * Acts as a barrier to prevent scope pollution in nested blocks.
 */
@DslMarker
annotation class AlchemistDsl
\end{minted}
\captionof{lstlisting}{Definition of the \texttt{@AlchemistDsl} annotation.}

\newpage

This annotation is applied to all key context interfaces in the DSL hierarchy, such as \texttt{SimulationContext} and \texttt{DeploymentsContext}. 
By marking these interfaces with a common DSL marker, 
the Kotlin compiler treats them as belonging to the same scope family. 
When these scopes are nested, the compiler enforces a rule of mutual exclusivity regarding implicit access: 
functions from an outer receiver are no longer callable without an explicit qualifier (e.g., \texttt{this@simulation}). 
This compile-time enforcement effectively guides the user to adhere to the correct domain hierarchy,
 transforming potential logical errors into syntax errors.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
@AlchemistDsl
interface SimulationContext<T, P : Position<P>> { ... }

@AlchemistDsl
interface DeploymentsContext<T, P : Position<P>> { ... }
\end{minted}
\captionof{lstlisting}{Example of \texttt{SimulationContext} and \texttt{DeploymentsContext} 
interfaces marked with the \texttt{@AlchemistDsl} annotation.}

However, enforcing strict scope isolation introduces a trade-off regarding data accessibility.
 While blocking access to outer \textit{operations} is needed to maintain structural correctness, blocking access to outer \textit{properties} can hinder usability. 
 Frequently, the instantiation of an object within an inner scope requires data available only in an outer scope.
  For instance, creating a specific \texttt{Point} deployment in space might require a reference to the global \texttt{environment} object defined in the root context.

To bridge this gap, initial implementations of the DSL exposed a \texttt{ctx} property within nested contexts,
 providing a controlled channel to access the outer scope explicitly.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
simulation {
    deployments {
        // 'ctx' provides explicit access to the outer environment
        deploy(Point(ctx.environment, 0.0, 1.0))
    }
}
\end{minted}
\captionof{lstlisting}{Example usage of the \texttt{ctx} property to access the outer environment.}

While functional, this manual context access was eventually replaced by the introduction of the \textit{DSL Processor}.
As detailed in the following section, the processor automatically generates helper functions that inject these contextual dependencies,
avoiding the manual use of \texttt{ctx}. 
Consequently, the \texttt{ctx} mechanism is currently deprecated, reserved only for edge cases where automated generation is not possible.

\subsection{Variables Management}
\label{sec:impl-variables}

As established in the design phase, one of the critical requirements for the DSL is the ability to support batch executions.
 This implies that variables defined in the configuration script cannot hold a single, immediate value. 
 Instead, they must act as \textit{placeholders} or \textit{references} that are resolved to specific values only when a specific 
 simulation instance is materialized.

To implement this deferred resolution mechanism in a way that feels natural to the user, the DSL leverages one of Kotlin's most powerful features: \textbf{Delegated Properties}.

\subsubsection{Variable Registration and Resolution}

In the Alchemist DSL, variables are managed by a central component called \texttt{VariablesContext}. 
When a user declares a variable using the \texttt{variable()} function, the following sequence of operations occurs:

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
val rate: Double by variable(LinearVariable(0.0, 1.0, 10.0))
\end{minted}

\begin{enumerate}
    \item \textbf{Provider Creation}: The \texttt{variable} function returns a \texttt{VariableProvider} instance, 
    holding the definition of the variable (e.g., the range of values it can take). The type of the variable should be an instance of the 
    \textit{Variable} interface.
    
    \item \textbf{Interception and Registration}: The \texttt{provideDelegate} operator is invoked. 
    The implementation uses the property \textbf{name} (e.g., rate) as a key to register the variable definition in the \texttt{VariablesContext}.
     Also in this phase, 
    the default value of the variable is registered in the \texttt{defaults} map, which will later be used to assign the initial value of variables during the materialization phase. 
    Note that the default value is a mandatory property of the \texttt{Variable} interface. 
\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
operator fun provideDelegate(thisRef: Any?, prop: KProperty<*>):
    ReadOnlyProperty<Any?, T> {
    // Check if the variable name already exists
    check(!variables.containsKey(prop.name) && 
    !dependentVariables.contains(prop.name)) {
        "Variable ${prop.name} already exists"
    }
    logger.debug("Registering variable: {}", prop.name)
    variables[prop.name] = source
    defaults[prop.name] = source.default
    return Ref()
}
\end{minted}
\captionof{lstlisting}{Implementation of the \texttt{provideDelegate} operator for the \texttt{variable} function.}
    \item \textbf{Delegate Creation}: The method returns a \texttt{Ref} instance, which acts as the runtime delegate for the property.
\end{enumerate}

This mechanism separates the \textit{definition} of the variable from its \textit{value}. 
The \texttt{Ref} delegate implements the \texttt{getValue} operator to resolve the value dynamically. 
Instead of storing the value itself, it queries a registry called \texttt{references}, looking up the value associated with the property's name.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
inner class Ref<T : Serializable> : ReadWriteProperty<Any?, T> {
    override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        // Fetch the value from the current context registry
        return references.get()[property.name] as T
    }
}
\end{minted}
\captionof{lstlisting}{Implementation of the \texttt{Ref} delegate \texttt{getValue} method.}

As described in the design \Cref{chap:design}, the variables' registry is populated during the materialization phase, by the \texttt{DSLLoader}, 
which is in charge of assigning the real value for each variable for each simulation instance in the batch. 
If the user attempts to access the variable \texttt{rate} during the script's definition phase (before the simulation is actually built),
 the \texttt{references} map will contain only defaults, and the access will function correctly. 
 However, the primary intended usage is during the \textit{materialization phase}, where the real values are assigned to the variables.

\subsubsection{Variable Reification}

The final piece of the mechanism is the \textbf{reification} process, initiated by the \texttt{DSLLoader}. 
Before building the simulation model, the loader populates the \texttt{references} map in the \texttt{VariablesContext} with 
the specific values for the current run. After that, the loader executes the build steps.


\begin{figure}
    \centering
    \includesvg[width=\textwidth]{figures/variableRegistry}
    \caption{Variables Context Design illustrating the mechanism for managing variable state across batch executions.}
    \label{fig:variables}
\end{figure}

During the execution of the build steps,
any access to the delegated properties (e.g., \texttt{deploy(point(x, y))}) triggers the \texttt{getValue} method of the \texttt{Ref} delegate. 
Since the \texttt{references} map is now \textbf{populated} with the values for that specific run, 
the property resolves to the correct value, effectively \textit{grounding} the simulation configuration.

While the legacy YAML configuration system explicitly models the concept of \textbf{dependent variables} (variables whose values are derived from others) 
to manage dependencies and order of evaluation, the DSL implementation can dispense with this formal distinction. 
By leveraging Kotlin's language features, dependent variables are simply defined as variables initialized with a lambda expression.

Since these expressions are lazily evaluated,
 they are resolved only when the simulation is materialized. If a dependent variable references a free variable within its definition,
  the access automatically triggers the \texttt{getValue} method of the corresponding delegate, fetching the correct value from the \texttt{references} map. 
  This approach offers greater flexibility than the YAML equivalent, allowing users to express dependencies naturally using standard 
  Kotlin syntax without needing to instantiate specialized \texttt{DependentVariable} types.

\newpage

\begin{minted}[fontsize=\scriptsize, linenos]{kotlin}
    val incarnation = SAPERE.incarnation<T, Euclidean2DPosition>()
    simulation(incarnation) {
        // Free variables
        val rate: Double by variable(GeometricVariable(2.0, 0.1, 10.0, 9))
        val size: Double by variable(LinearVariable(5.0, 1.0, 10.0, 1.0))

        // Dependent variables: defined as functions of other variables
        val mSize by variable { -size }
        val sourceStart by variable { mSize / 10.0 }
        val sourceSize by variable { size / 5.0 }

        terminators { +AfterTime<T, P>(DoubleTime(1.0)) }
        networkModel = ConnectWithinDistance(0.5)
        deployments {
            deploy(
                grid(mSize, mSize, size, size, 0.25, 0.25, 0.1, 0.1),
            ) {
                inside(Rectangle(sourceStart, sourceStart, sourceSize, sourceSize)) {
                    molecule = "token, 0, []"
                }
                programs {
                    all {
                        timeDistribution(rate.toString())
                        program = "{token, N, L} --> {token, N, L} *{token, N+#D, L add [#NODE;]}"
                    }
                    all {
                        program = "{token, N, L}{token, def: N2>=N, L2} --> {token, N, L}"
                    }
                }
            }
        }
    }
 \end{minted}
\captionof{lstlisting}{Example of DSL syntax with variables.}

The structure of the language inherently prevents circular dependencies. 
Since local variables in Kotlin must be defined before use, it is syntactically impossible to reference a variable that has not yet been declared. 
This compile-time constraint eliminates the need for the complex runtime cycle detection logic required by the YAML loader. Furthermore, 
to enforce immutability within the simulation logic, the delegate's \texttt{setValue} method is implemented to throw an exception, preventing users from manually reassigning variable values.
\newpage

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
    // Define a free variable
    val rate: Double by variable(LinearVariable(0.0, 1.0, 10.0))
    
    // Compilation Error: 'validVariable' cannot be accessed before definition
    val invalidVariable: Double by variable { validVariable * 2 }
    
    val validVariable: Double by variable { invalidVariable * rate }
\end{minted}
\captionof{lstlisting}{Example of a compilation error caused by a circular dependency.}
    
Consequently, while the legacy \texttt{Loader} interface maintains a list of \texttt{DependentVariable} objects,
 the new \texttt{DSLLoader} can safely ignore this field, relying entirely on Kotlin's native delegation and scope resolution 
 mechanisms to handle variable dependencies. 
 
 To handle \textbf{constants}, the DSL simply leverages the Kotlin language, by letting users define a variable with a constant value.
 There is no need to handle them in a special way since they do not depend on other variables, so they are treated as regular 
 Kotlin variables. Constants can be defined at any context level, even outside the DSL context.
 This design simplifies the internal architecture while providing a more intuitive and type-safe experience for the user.

\subsection{Batch Mode Support}
\label{sec:batch-mode}

The support for batch executions creates a unique challenge in the context of a DSL-based configuration. 
Unlike the YAML loader, which parses the configuration file and constructs a completely new object graph for every simulation instance, 
the Kotlin DSL evaluates the user's script only once. 
This single evaluation (definition phase) produces a \textit{prototype} \texttt{SimulationContext} object, 
containing the list of build steps and the definitions of all variables.
Later, when the \texttt{build} method of the \texttt{SimulationContext} is invoked, it creates a copy of the prototype context 
and injects the variable values for the current run into the copy. Then the build steps are executed on the copy instance, 
rather than on the prototype instance.

This architectural choice optimizes performance by avoiding repetitive script parsing and compilation. 
However, it introduces a concurrency issue regarding the state of the variables. 
Since the build steps are defined as lambdas within the scope of this single prototype context, 
they capture the variable delegates associated with that \textit{specific} context instance (the prototype context). 
Even duplicating the \texttt{VariablesContext}, the problem persists, because the build steps are still defined as lambdas within the scope of the prototype context, 
so they will reference the same variable delegates.
Consequently, the \texttt{VariablesContext} is effectively a shared resource across all simulation instances generated from that script.

Crucially, the Alchemist architecture specifies that simulation instances are \textbf{independent} execution units, designed to run concurrently on separate threads. 
This behavior is contractually defined by the \texttt{Simulation} interface, which extends \texttt{Runnable}. 
Consequently, the materialization and execution of each simulation instance occur within a unique thread context.
Each thread is responsible for materializing and running a specific simulation instance with a distinct set of variable values.
If the \texttt{VariablesContext} stored the current variable values in a simple mutable map, 
concurrent threads attempting to build different simulations would race to overwrite these values, 
leading to inconsistent states where a simulation might be built using the parameters intended for another.

To resolve this conflict without sacrificing the benefits of parallel execution, the implementation leverages \textbf{thread-local} 
storage\footnote{\url{https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html}}.
The \texttt{VariablesContext} does not store the mapping of variable names to values in a standard field. 
Instead, it wraps the registry in a \texttt{ThreadLocal} container.

\begin{figure}[htbp]
    \centering
    \includesvg[width=\textwidth]{figures/batchvars}
    \caption{Diagram illustrating the thread-local variable resolution during batch execution.}
    \label{fig:batch-execution-sequence}
\end{figure}

This mechanism ensures that the state of the variables is isolated per thread. 
When a variable is accessed, the \texttt{getValue} method will fetch the shared registry of the \texttt{VariablesContext}, but it will only
see the values available for that simulation instance thread.


\newpage
\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
class VariablesContext {
    // ...
    /** Thread-local map of variable references. */
    val references = object : ThreadLocal<Map<String, Any>>() {
        override fun initialValue(): Map<String, Any> {
            // initialize the map with the defaults
            return defaults.toMap()
        }
    }
    
    fun addReferences(newRefs: Map<String, *>) {
        val currMap = references.get()
        // Updates the map only for the current thread
        val updatedMap = currMap + newRefs 
        references.set(updatedMap)
    }
}
\end{minted}
\captionof{lstlisting}{Definition of the \texttt{ThreadLocal} registry inside the \texttt{VariablesContext} class.}


The materialization flow proceeds as follows:

\begin{enumerate}
    \item One \texttt{Loader} is created for each simulation instance.
    \item The variables' values for the current run are injected into the \texttt{ThreadLocal} registry of the shared \texttt{VariablesContext}.
     This operation affects only the \textit{view} of the variables seen by the current thread.
    \item The build steps are executed on the \textbf{copy instance}, rather than on the prototype instance.
    \item As these steps execute, they access the variable delegates. Although these delegates belong to the shared context, their \texttt{getValue} method queries the \texttt{ThreadLocal} map.
    Consequently, the delegate resolves the variable value correctly for the specific simulation being built by that thread, ignoring any values set by other concurrent threads.
\end{enumerate}


This design effectively exploits the \textit{thread-per-simulation} model typically employed by the Alchemist \texttt{Launcher}. 
It allows the DSL to maintain a singleton-like definition structure while supporting the safe, parallel instantiation of heterogeneous simulation models.


%----------------------------------------------------------------------------------------
\section{KSP Implementation}
\label{sec:ksp-implementation}
%----------------------------------------------------------------------------------------

To address the usability challenges identified in the \Cref{chap:analysis}, specifically the parameter injection overhead, the context chaining verbosity, and the generic type mismatches, 
the system employs a generative approach powered by the \textbf{Kotlin Symbol Processing} (KSP) API.

The core component is the \texttt{DslBuilderProcessor}, which automates the creation of the DSL integration layer. 
By annotating Alchemist components with \texttt{@AlchemistKotlinDSL}, developers trigger the automatic generation of type-safe, context-aware factory functions. 
These functions bridge the gap between the declarative DSL syntax and the complex instantiation requirements of the underlying Java/Kotlin classes.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
deployments {
    // 'environment' is injected automatically from the context
    deploy(point(0.0, 0.0)) 
    // instead of Point(ctx.environment, 0.0, 0.0)
}
\end{minted}
\captionof{lstlisting}{Example of DSL usage with automatic context injection.}

This section details the architecture of the processor and the specific mechanisms used to solve each usability challenge.

\subsection{Usability Problems}
\label{sec:context-access-challenge}
Transitioning from a dynamic YAML configuration to a static DSL introduces three significant usability hurdles related to dependency management and scope nesting.

The first challenge is the \textbf{parameter injection overhead}. Alchemist's domain objects, such as deployments (e.g., \texttt{Grid}) or node properties (e.g., \texttt{BrownianMove}),
 often require references to infrastructural components like the \texttt{Environment} or the \texttt{RandomGenerator} in their constructors.
In the legacy YAML system, these dependencies are auto-injected dynamically via reflection. In a static Kotlin DSL, however, a direct constructor call would require the user to manually pass these instances.
\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
// Without automation, the user must manually pass system dependencies
deploy(Grid(ctx.environment, ctx.randomGenerator, 0.0, 0.0, ...))
\end{minted}
This verbosity breaks the declarative nature of the configuration, forcing users to handle technical dependencies that should be transparent.

The second challenge is the \textbf{context chaining problem}. The DSL's hierarchical structure mirrors the simulation model: 
a \texttt{Simulation} contains \texttt{Deployments}, which contain \texttt{Nodes}, which contain \texttt{Programs}. This creates a deep nesting of context objects.
When a leaf component (like a reaction inside a node) requires a root-level dependency (like the environment), accessing it via the receiver hierarchy becomes cumbersome.
In the initial prototype, this required explicit chaining of context references, leading to unreadable code such as \texttt{ctx.ctx.ctx.environment}. 
This not only degrades readability but also tightly couples the user script to the internal implementation details of the context hierarchy.

The third usability challenge involves the \textbf{generic type mismatch} inherent in the legacy codebase.
 As discussed in \Cref{chap:analysis}, many Alchemist domain classes (e.g., \texttt{Grid}) are not generic over the simulation types \texttt{T} and \texttt{P}. 
 Instead, they often implement interfaces with star-projected types (e.g., \texttt{Deployment<Position<*>>}), effectively erasing type information.
A strict DSL would require users to manually cast these objects to the specific \texttt{Deployment<P>} type expected by the context, leading to verbose and error-prone configuration scripts.


\subsection{Symbol Processing Pipeline}

The code generation process is orchestrated by the \texttt{DslBuilderProcessor} class,
 which implements the standard KSP \texttt{SymbolProcessor} interface. 
 The pipeline proceeds in four distinct stages:

\begin{enumerate}
    \item \textbf{Symbol Discovery}: The processor queries the KSP resolver to identify all classes annotated with \texttt{@AlchemistKotlinDSL}. 
    It filters the results to ensure that only valid, concrete class declarations are processed.
    
    \item \textbf{Constructor Analysis}: The \texttt{ConstructorFinder} selects the most suitable constructor for instantiation, prioritizing the primary constructor. 
    Subsequently, the \texttt{ParameterInjector} analyzes the parameter list, cross-referencing types against the supported injections defined in \texttt{ProcessorConfig} 
    to distinguish between user-supplied arguments and injectable dependencies.
    
    \item \textbf{Context Determination}: Based on the identified dependencies and any explicit scope constraints, 
    the processor infers the appropriate \texttt{ContextType} required for the factory function. 
    The inference logic defaults to the \textbf{outermost} context capable of satisfying all dependencies.
    For example, if a class requires only the \texttt{Environment}, the context type will be \texttt{SIMULATION},
     because it can be accessed from the simulation context.
    However, it is not possible to determine if that component will be used inside a deployment, a program, a property, etc.
    This avoids requiring users to manually specify the context of the function signature during the annotation usage.
    
    \item \textbf{Code Generation}: The \texttt{CodeGenerator} synthesizes the final Kotlin source file. 
    This stage constructs the factory function signature with the appropriate context receivers and generic type parameters, ensuring strict type safety. 
    The function body is then populated with the logic to resolve dependencies using the calculated accessor paths and to instantiate the target class.
\end{enumerate}

\subsection{Automatic Dependency Injection}

\label{sec:auto-injection}

To address the parameter injection overhead and the context chaining problem, the DSL implementation introduces a purely generative approach via the \texttt{DslBuilderProcessor}.
The processor's primary responsibility is to generate \textit{factory functions} that bridge the gap between the simplified DSL API and the complex constructors of Alchemist objects.
The main goal here is to enhance the usability of the DSL, without sacrificing type safety.

The solution relies on \textbf{context analysis} to distinguish between user-configurable parameters and system-injectable dependencies. 
The processor scans the primary constructor of each class annotated with \texttt{@AlchemistKotlinDSL} and classifies its parameters.
If a parameter type matches a known infrastructural component (e.g., \texttt{Environment}, \texttt{RandomGenerator}, \texttt{Incarnation}), 
it is marked for \textbf{auto-injection}. 
All other parameters are considered configuration values to be provided by the user.

Based on this analysis, the processor generates a helper function with a simplified signature. 
Internally, this function retrieves the required dependencies from the current scope and invokes the actual constructor.
Crucially, to solve the context chaining problem, the processor statically calculates the access path required to reach a dependency from the current context depth.
Logic within the \texttt{ContextAccessor} component maps the injection type (e.g., \texttt{ENVIRONMENT}) and the current context level (e.g., \texttt{PROGRAM}) to the correct 
accessor string (e.g., \texttt{ctx.ctx.ctx.env}), effectively hiding the complexity of the hierarchy from the user.


\begin{minted}[fontsize=\scriptsize, linenos]{kotlin}
private fun getDeploymentContextAccessor(injectionType: InjectionType, contextParamName: String): String =
when (injectionType) {
    InjectionType.ENVIRONMENT -> "$contextParamName.ctx.ctx.environment"
    InjectionType.GENERATOR -> "$contextParamName.ctx.generator"
    InjectionType.INCARNATION -> "$contextParamName.ctx.ctx.incarnation"
    InjectionType.FILTER -> "$contextParamName.filter"
    InjectionType.NODE -> throw IllegalArgumentException("NODE is not available in DeploymentContext")
    InjectionType.REACTION -> throw IllegalArgumentException(
        "REACTION is not available in DeploymentContext",
        )
    InjectionType.TIMEDISTRIBUTION -> throw IllegalArgumentException(
        "TIMEDISTRIBUTION is not available in DeploymentContext",
    )
}
\end{minted}
\captionof{lstlisting}{The \texttt{getDeploymentContextAccessor} function, which is used to generate
 the accessor path for the \texttt{DeploymentContext}.}

This example shows the \textit{accessor} paths for each injection type available in the \texttt{DeploymentContext}. The injectable parameters that are not 
available in the \texttt{DeploymentContext} are not included in the accessor path, so they throw an exception if requested. 
A function of this kind exists for each context type, and is used to generate the accessor path for each injection type.

While this approach is simple and effective, it would require manual updates to the accessor logic if new context types were introduced. 
However, the extensibility of the Alchemist simulator depends not on modifying the core meta-model or syntax structure, but on introducing new implementations
 of existing components (e.g., custom deployments, exporters, or output monitors). 
Consequently, the DSL processor supports this primary form of extensibility: users can seamlessly generate the necessary helper functions for their custom components 
simply by applying the \texttt{@AlchemistKotlinDSL} annotation.


\subsubsection{Leveraging Context Parameters}

To implement this injection transparently,
the generated code utilizes Kotlin's experimental \textbf{Context Parameters} feature.
Unlike standard extension functions, which modify the \texttt{this} receiver, context parameters allow functions to declare dependencies on a context without 
occupying the implicit receiver slot.

The processor generates functions using the following pattern:

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
context(ctx: SimulationContext<T, P>)
fun grid(xStart: Double, ...): Grid {
    // 'ctx' is available here implicitly
    // The processor generates the correct path to access the environment
    return Grid(ctx.environment, ctx.scenarioGenerator, xStart, ...)
}
\end{minted}
\captionof{lstlisting}{Example of context parameter usage in the \texttt{grid} function generated by the processor.}

This approach guarantees that the helper functions are \textbf{top-level} functions that are only
callable when the required context is present.
They do not need to be members of the Context interfaces, keeping the API surface clean.
 

\subsubsection{Scope Customization}

While the processor can infer the required scope based on constructor parameters, 
the system allows for explicit control via the \texttt{@AlchemistKotlinDSL} annotation. 
Since the DSL infers the context from the dependencies, picking the outermost context that can satisfy all dependencies,
sometimes it is necessary to restrict the context in which the component can be used.
For example, the \texttt{Point} deployment class has the following constructor:
\newpage
\begin{minted}[fontsize=\scriptsize, linenos]{java}
public Point(final Environment<?, P> environment, final double x, final double y) {
    this.x = x;
    this.y = y;
    positionMaker = environment::makePosition;
}
\end{minted}
\captionof{lstlisting}{Constructor of the \texttt{Point} deployment class.}

The only injectable parameter is the \texttt{environment}, so the inferred context type will be \texttt{SIMULATION\_CONTEXT},
 because the environment can be accessed from the simulation context.
This means that the generated \texttt{point()} function will be callable only inside the simulation context scope.
However, the correct scope should be the \texttt{DEPLOYMENTS\_CONTEXT} since the \texttt{Point} class is a deployment, and for this reason, 
it should be used inside the \textit{deployments} block. To address this issue, the user can specify the scope manually 
using the \texttt{scope} parameter of the \texttt{@AlchemistKotlinDSL} annotation.

\begin{minted}[fontsize=\scriptsize, linenos]{java}
@AlchemistKotlinDSL(scope = "DEPLOYMENTS_CONTEXT")
public final class Point<P extends Position<? extends P>> implements Deployment<P> {
    // ...
}    
\end{minted}
\captionof{lstlisting}{Example of using the \texttt{scope} parameter to specify the 
context type for the \texttt{Point} deployment class.}

If a user specifies a scope that cannot satisfy the class's dependencies (e.g., requesting \texttt{SimulationContext} for a class that requires a \texttt{Node}),
the processor will fail to inject the dependencies, requesting them in the function signature.
This customization ensures more control over the context in which the component can be used.

Additionally, the \texttt{@AlchemistKotlinDSL} annotation provides the \texttt{functionName} parameter, 
allowing developers to customize the name of the generated factory function. 
By default, the processor derives the name from the class (e.g., \texttt{Grid} becomes \texttt{grid}), 
but this override enables authors to provide more idiomatic or domain-specific names when necessary.

\subsubsection{Generic Type Mismatch}

To address the generic type mismatch challenge, described in \Cref{sec:context-access-challenge},    
the processor implements a simple type matching strategy.
During the code generation phase, 
the \texttt{ConstructorParamBuilder} component analyzes the type signature of each constructor parameter and compares it with the type of the corresponding object 
available in the context.
When a mismatch is detected, for instance, if a constructor requires a star-projected \texttt{Environment<*, *>} while the context provides a strictly typed \texttt{Environment<T, P>},
the processor automatically generates an internal cast (e.g., \texttt{ctx.environment as Environment<*, *>}). 

Furthermore, the \texttt{BoundProcessor} component ensures the correct handling of type variance. 
Many Alchemist interfaces utilize covariance and contravariance (e.g., \texttt{in T} or \texttt{out P}) to maximize flexibility. 
The processor parses these variance annotations and propagates them correctly into the generated function signatures.
This automated management of casts and variance is needed to maximize the usability of the DSL, without sacrificing type safety.


