%----------------------------------------------------------------------------------------
\chapter{Implementation}
\label{chap:implementation}
%----------------------------------------------------------------------------------------

\section{DSL Implementation} 

The implementation of the Alchemist DSL leverages the advanced features of the Kotlin language to create a type-safe, declarative configuration system. The following sections detail the core mechanisms used to build the DSL, focusing on the builder pattern, variable management, and the integration with the Alchemist loading system.

\subsection{Builder Functions}

The declarative syntax of the Alchemist DSL relies on Kotlin's \textit{function literals with receiver}. 
This feature allows a lambda expression to adopt the scope of a specific receiver object, binding the \texttt{this} keyword within the lambda to that object.
 This enables the creation of hierarchical structures where nested blocks map to nested context objects, reflecting the domain model outlined in Chapter~\ref{chap:design}.

In the implementation, each DSL scope is backed by a specific \textit{Context} interface,
 which defines the operations and properties available within that scope. 
 For example, the \texttt{SimulationContext} interface exposes top-level configuration methods, 
 while the \texttt{DeploymentsContext} interface limits operations to those relevant to node deployment.

The pattern typically involves an interface enriched with higher-order functions that accept lambdas with receivers. 
Consider the \texttt{deployments} function in the \texttt{SimulationContext} interface:

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
interface SimulationContext<T, P : Position<P>> {
    // ...
    /**
     * Configures node deployments for the simulation.
     */
    fun deployments(block: DeploymentsContext<T, P>.() -> Unit)
    // ...
}
\end{minted}

When a user invokes \verb|deployments { ... }|, the lambda passed as the \texttt{block} argument executes with a \texttt{DeploymentsContext} instance as its receiver.
 This allows the implementation class, \texttt{SimulationContextImpl}, to instantiate the context, apply the user's configuration block, and store the result. 
 Using interfaces as receivers restricts the visibility of internal variables and methods, preventing accidental access to internal state from the DSL script.
 

 To guarantee type safety throughout the DSL, every \textit{Context} interface is defined as generic, parameterized by types \texttt{T} and \texttt{P}. 
 When constructing a simulation, the user is required to specify these types explicitly—ensuring that the type of concentration (\texttt{T}) and the position
  representation (\texttt{P}) are established up front.
 As a consequence, all operations and properties accessible within the various context interfaces are inherently generic and bound to the chosen types.
 This design ensures that, within each scope, all entities and DSL constructs consistently adhere to the type constraints specified at the root of the simulation definition.

 \begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
    val incarnation = SAPERE.incarnation<Double, Euclidean2DPosition>()
    simulation(incarnation) {
        // Inside this scope and all the nested scopes, 
        // T and P must be Double and Euclidean2DPosition
        networkModel = ConnectWithinDistance(5.0)
        deployments {
            deploy(point(0.0, 0.0)){
                // ...
            }
            deploy(point(0.0, 1.0)){
                // ...
            }
        }
    }
     \end{minted}
     \captionof{lstlisting}{Example of DSL syntax}


\subsection{Execution Order}
As described in the design chapter~\ref{chap:design}, execution is often deferred and stored in a list of \textit{build steps}:

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
override fun deployments(block: DeploymentsContext<T, P>.() -> Unit) {
    buildSteps.add {
        DeploymentsContextImpl(this).apply(block)
    }
}
\end{minted}

This pattern recurs throughout the DSL. The \texttt{DeploymentsContext} exposes a \texttt{deploy} function that accepts a \texttt{DeploymentContext} receiver, 
building a \textit{tree} of context objects that mirrors the configuration's hierarchy.

Preserving the execution order of these build steps is critical for consistent random number generation. 
The DSL script must produce a simulation model \textbf{identical} to the one generated by the YAML configuration. 
To achieve this, the order of declarations in the DSL script must match the sequence of build steps in the YAML configuration.
 Any different order would alter the consumption of the random number generators, leading to different simulation results. 
 The random number generators are heavily used, by the simulation model, to generate model entities such as nodes, positions, reactions, etc.

In the existing implementation,
 the simulation model is created directly within the \textit{Loader} component.
  This results in a monolithic class responsible for the entire model's creation, which is difficult to maintain and extend.

\begin{figure}[H]
    \centering
    \includesvg[width=0.5\textwidth]{figures/yamlLoader}
    \caption{Legacy YAML Loader Architecture}
    \label{fig:yamlLoader}
\end{figure}

The model is built using a \textit{depth-first} traversal of the context tree. 
This ensures dependencies are resolved before moving forward. 
As shown in the example in Figure~\ref{fig:dfsTraversal}, with two deployments, 
the system fully materializes the first before starting the second.
 Within a deployment, it iterates through the generated nodes. 
 For each node, it injects properties and contents, then attaches reaction programs, and finally adds the node to the environment. 
 This deterministic order is essential for consistency with the legacy YAML loader's random number generation.

\begin{figure}[H]
    \centering
    \includesvg[width=\textwidth]{figures/dfs}
    \caption{Depth-First Traversal of the Configuration Tree}
    \label{fig:dfsTraversal}
\end{figure}

The proposed implementation addresses the \textit{monolithic class} problem by delegating responsibilities to the individual contexts, 
while preserving the necessary depth-first traversal. 
Most context implementation classes define an \textit{apply}-prefixed method (e.g., \texttt{applyToNode}), hidden from DSL users, 
which the loader uses internally to modify the simulation model.

\begin{figure}[H]
    \centering
    \includesvg[width=\textwidth]{figures/dslbuildsteps}
    \caption{DSL Context Delegation Flow}
    \label{fig:dslDelegation}
\end{figure}

By delegating creation logic, each context manages only its specific part of the simulation model. 
This approach enforces the separation of concerns and improves the code modularity.


\subsection{Scope Control via DSL Markers}

A significant challenge in the design of DSLs based on nested builder patterns is the phenomenon of \textit{scope leakage}. 
By default, Kotlin allows lambdas with receivers to access members of their enclosing scopes implicitly. 
While this behavior facilitates concise code in many scenarios, within the Alchemist configuration domain, it poses a risk of structural ambiguity.
 Without strict boundaries, a user could inadvertently invoke methods from an outer context within a nested block—for example,
  defining a \texttt{deployment} inside another \texttt{deployment}. 
  Such constructs, while syntactically valid in Kotlin, violate the semantic constraints of the simulation model.

To mitigate this risk and enforce strict structural integrity, 
the implementation leverages the \texttt{@DslMarker} meta-annotation provided by the Kotlin standard library. 
This mechanism allows for the definition of a custom annotation, \texttt{@AlchemistDsl}, which acts as a boundary for implicit receiver resolution.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
/**
 * Marker annotation for Alchemist DSL elements.
 * acts as a barrier to prevent scope pollution in nested blocks.
 */
@DslMarker
annotation class AlchemistDsl
\end{minted}

This annotation is applied to all key context interfaces in the DSL hierarchy, such as \texttt{SimulationContext} and \texttt{DeploymentsContext}. 
By marking these interfaces with a common DSL marker, 
the Kotlin compiler treats them as belonging to the same scope family. 
When these scopes are nested, the compiler enforces a rule of mutual exclusivity regarding implicit access: 
functions from an outer receiver are no longer callable without an explicit qualifier (e.g., \texttt{this@simulation}). 
This compile-time enforcement effectively guides the user to adhere to the correct domain hierarchy,
 transforming potential logical errors into syntax errors.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
@AlchemistDsl
interface SimulationContext<T, P : Position<P>> { ... }

@AlchemistDsl
interface DeploymentsContext<T, P : Position<P>> { ... }
\end{minted}

However, enforcing strict scope isolation introduces a trade-off regarding data accessibility.
 While blocking access to outer \textit{operations} is needed to maintain structural correctness, blocking access to outer \textit{properties} can hinder usability. 
 Frequently, the instantiation of an object within an inner scope requires data available only in an outer scope.
  For instance, creating a specific \texttt{Point} deployment in space might require a reference to the global \texttt{environment} object defined in the root context.

To bridge this gap, initial implementations of the DSL exposed a \texttt{ctx} property within nested contexts,
 providing a controlled channel to access the outer scope explicitly.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
simulation {
    deployments {
        // 'ctx' provides explicit access to the outer environment
        deploy(Point(ctx.environment, 0.0, 1.0))
    }
}
\end{minted}

While functional, this manual context access was eventually replaced by the introduction of the \textit{DSL Processor}.
As detailed in the following section, the processor automatically generates helper functions that inject these contextual dependencies,
avoiding the manual use of \texttt{ctx}. 
Consequently, the \texttt{ctx} mechanism is currently deprecated, reserved only for edge cases where automated generation is not possible.

\subsection{Variables Management}
\label{sec:impl-variables}

As established in the design phase, one of the critical requirements for the DSL is the ability to support batch executions.
 This implies that variables defined in the configuration script cannot hold a single, immediate value. 
 Instead, they must act as \textit{placeholders} or \textit{references} that are resolved to specific values only when a specific 
 simulation instance is materialized.

To implement this deferred resolution mechanism in a way that feels natural to the user, the DSL leverages one of Kotlin's most powerful features: \textbf{Delegated Properties}.

\subsubsection{Delegated Properties Mechanism}

Kotlin's delegated properties allow developers to offload the logic for reading and writing a property to a separate helper object,
 known as the \textit{delegate}. The syntax \texttt{val x: Type by delegate} instructs the compiler to generate code that redirects 
 all accessors of \texttt{x} to the \texttt{getValue} (and \texttt{setValue} for mutable properties) method of the delegate instance.

Moreover, Kotlin provides an interception hook called \texttt{provideDelegate}, which allows the delegate provider to inspect 
the property \textit{at the moment of its declaration}. This hook receives a \texttt{KProperty} object containing metadata about the property, 
most notably its \textbf{name}.
 This feature is the cornerstone of the Alchemist DSL's variable system, as it allows the framework to automatically register variables using their declared names 
 without requiring redundant string literals.

\subsubsection{Variable Registration and Resolution}

In the Alchemist DSL, variables are managed by a central component called \texttt{VariablesContext}. 
When a user declares a variable using the \texttt{variable()} function, the following sequence of operations occurs:

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
val rate: Double by variable(LinearVariable(0.0, 1.0, 10.0))
\end{minted}

\begin{enumerate}
    \item \textbf{Provider Creation}: The \texttt{variable} function returns a \texttt{VariableProvider} instance, 
    holding the definition of the variable (e.g., the range of values it can take).
    
    \item \textbf{Interception and Registration}: The \texttt{provideDelegate} operator is invoked. 
    The implementation uses the property name (e.g., "rate") as a key to register the variable definition in the \texttt{VariablesContext}.
    
\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
operator fun provideDelegate(thisRef: Any?, prop: KProperty<*>):
 ReadOnlyProperty<Any?, T> {
    check(!variables.containsKey(prop.name)) { "Variable ${prop.name} already exists" }
    // Register the variable source using the property name as key
    variables[prop.name] = source 
    return Ref() // Return the actual delegate
}
\end{minted}

    \item \textbf{Delegate Creation}: The method returns a \texttt{Ref} instance, which acts as the runtime delegate for the property.
\end{enumerate}

This mechanism separates the \textit{definition} of the variable from its \textit{value}. 
The \texttt{Ref} delegate implements the \texttt{getValue} operator to resolve the value dynamically. 
Instead of storing the value itself, it queries a registry called \texttt{references}, looking up the value associated with the property's name.

\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
inner class Ref<T : Serializable> : ReadWriteProperty<Any?, T> {
    override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        // Fetch the value from the current context registry
        return references.get()[property.name] as T
    }
}
\end{minted}

\begin{figure}[H]
    \centering
    \includesvg[width=\textwidth]{figures/variableRegistry}
    \caption{Variables Context Design}
    \label{fig:variables}
\end{figure}

If the user attempts to access the variable \texttt{rate} during the script's definition phase (before the simulation is actually built),
 the \texttt{references} map will be empty or contain only defaults, and the access will function correctly or fail gracefully depending on the state. 
 However, the primary intended usage is during the \textit{materialization phase}.

\subsubsection{Variable Reification}

The final piece of the mechanism is the \textbf{reification} process, handled by the \texttt{DSLLoader}. 
When the system prepares to launch a batch of simulations, it iterates through the generated parameter combinations. 
For each specific combination (a map of \texttt{String} names to values):

\begin{enumerate}
    \item The loader acquires the \texttt{SimulationContext}.
    \item It populates the \texttt{references} map in the \texttt{VariablesContext} with the specific values for the current run.
    \item It executes the build steps.
\end{enumerate}

During the execution of the build steps,
 any access to the delegated properties (e.g., \texttt{deploy(point(x, y))}) triggers the \texttt{getValue} method of the \texttt{Ref} delegate. 
 Since the \texttt{references} map is now \textbf{populated} with the values for that specific run, 
 the property resolves to the correct value, effectively \textit{grounding} the simulation configuration.

This design achieves a high degree of transparency: the user works with standard Kotlin properties, 
type-checked by the compiler, while the underlying DSL machinery transparently handles the complexity of batch variation and \textit{deferred execution}.
\subsection{Batch Mode Support}
\section{KSP Implementation}
\subsection{Symbol Processing Pipeline}
\subsection{Code Generation Strategy}
\subsection{Context Injection Mechanism}
