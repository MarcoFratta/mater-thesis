%----------------------------------------------------------------------------------------
\chapter{Conclusion and Future Work}
\label{chap:conclusion}
%----------------------------------------------------------------------------------------

\paragraph{Conclusion}

This thesis presents a methodology for constructing type-safe internal Domain-Specific Languages that replace untyped 
declarative configuration formats with General-Purpose Language-based solutions, preserving semantic equivalence while 
introducing compile-time safety and enhanced developer experience.

The central insight of this work is that internal DSLs built on modern language features can successfully reconcile 
the static verification requirements of type-safe systems with the dynamic extensibility demands of complex frameworks. 
Rather than requiring extensive refactoring of existing codebases, the approach employs code generation techniques 
to bridge the gap between simplified DSL APIs and legacy component interfaces, enabling incremental adoption without 
compromising type safety or usability.

A key finding is that generative approaches, specifically leveraging compiler plugin APIs like Kotlin Symbol Processing, 
provide a practical pathway for integrating DSLs with systems that were not originally designed for type-safe configuration. 
This technique addresses the fundamental tension between static verification and runtime flexibility, offering a scalable 
solution applicable beyond the immediate use case.

The methodology demonstrates that transitioning from data-serialization formats to type-safe configuration languages 
yields substantial benefits: errors are caught during development rather than execution, tooling support becomes 
comprehensive rather than limited, and configuration evolves from monolithic files to composable, reusable modules. 
These advantages become particularly pronounced in domains with complex, recurring configuration patterns.

The Alchemist simulation framework serves as a concrete validation of this methodology, demonstrating its applicability 
to a real-world, extensible system. The resulting DSL maintains full semantic equivalence with the legacy YAML-based 
configuration while providing the type safety, tooling support, and modularity benefits that justify the transition 
from untyped to type-safe configuration languages.


\paragraph{Future Work}

While the current implementation successfully addresses the core requirements, several directions for future enhancement
present themselves.
A natural extension would be the development of conversion tools that enable seamless migration between YAML and DSL formats. 
A \textbf{YAML-to-DSL converter} could automatically translate existing YAML configurations into equivalent DSL scripts,
facilitating the migration of legacy configurations.

Currently, the DSL handles node programs as generic string values, 
requiring users to write reactions using the native syntax of each 
incarnation (e.g., \texttt{"\{token\} --> \{firing\}"}).
While this approach maintains compatibility with the existing Alchemist architecture, 
it sacrifices the type safety and IDE support that are core benefits of the DSL.

Future work could extend the DSL to support \textbf{custom} DSLs for each incarnation, allowing users to define 
programs using incarnation-specific syntax that is fully integrated with Kotlin's type system. 
For example, instead of string-based 
reaction definitions, the SAPERE incarnation could provide a DSL that allows users to define eco-laws using type-safe constructs:
\begin{minted}[fontsize=\footnotesize, linenos]{kotlin}
sapere {
    deployments {
        programs {
            ecoLaw {
                consume("token")
                produce("firing")
            }
        }
    }
}
\end{minted}

